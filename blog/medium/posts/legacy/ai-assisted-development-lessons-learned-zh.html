<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的AI编程伙伴差点让项目翻车：一个惨痛的教训</title>
    <style>
        body { font-family: Georgia, serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; line-height: 1.7; color: #333; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        h2 { font-size: 1.4rem; margin-top: 2rem; }
        pre { background: #f4f4f4; padding: 1rem; overflow-x: auto; border-radius: 4px; }
        code { font-family: Menlo, Monaco, monospace; font-size: 0.9em; }
        p code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; }
        img { max-width: 100%; }
        blockquote { border-left: 3px solid #ddd; margin-left: 0; padding-left: 1rem; color: #666; }
        ul { padding-left: 1.5rem; }
        hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        a { color: #1a8917; }
    </style>
</head>
<body>
<hr>
<h2>date: 2025-07-27
tags: [ai, ai, 软件开发, 架构设计, 最佳实践, asyncio, python]
legacy: true</h2>
<h1>我的AI编程伙伴差点让项目翻车：一个惨痛的教训</h1>
<ol>
<li><strong>核心调度引擎</strong>：一个健壮的、基于<code>asyncio</code>的调度器。</li>
<li><strong>智能任务执行</strong>：一个能够分析任务结果并动态调整未来运行参数的系统。</li>
<li><strong>自我改进任务生成</strong>：AI可以根据性能指标或失败重写任务底层脚本的功能。</li>
<li><strong>人工票务系统</strong>：当任务不可恢复地失败时，系统会生成一个&quot;工单&quot;，人类可以审查、注释解决方案并反馈到系统的知识库中。</li>
</ol>
<p>AI勤奋地产出代码。票务系统被构建，自我改进钩子被添加，调度器被连接起来。表面上看，这像是一个巨大的成功。问题在于我在充当项目经理，而不是架构师。我在指定<em>构建什么</em>，但我没有严格指导<em>如何</em>构建和集成。</p>
<h2>与现实的碰撞：AI末日四骑士</h2>
<p>快速、未经审查的开发周期掩盖了深层次的问题。当我最终试图运行集成系统时，它崩溃了。根本原因并不新颖或奇特；它们是经典的软件工程失败，被AI放大和加速了。</p>
<h3>1. 过度工程的诱惑之歌</h3>
<p>AI没有业务上下文或架构前瞻性来说&quot;这一次太多了&quot;。它是一个极其强大的实现引擎。通过一次性要求所有功能，我无意中指导它为一个还不存在的未来构建解决方案，忽略了对稳定基础的直接需求。&quot;智能&quot;功能被强行附加到一个从未经过压力测试的核心上，创造了一个寻找问题的解决方案。</p>
<h3>2. 技术债务雪崩</h3>
<p>这就是理论问题变得痛苦具体的地方。AI在努力满足所有请求时，做出了创造根本冲突的权宜之计。</p>
<p>最明显的问题是<code>asyncio</code>事件循环冲突。不同的模块，可能在不同的AI提示中开发，试图独立管理事件循环。例如，核心调度器可能是这样初始化的：</p>
<p><strong>问题代码片段1：冲突的事件循环</strong></p>
<blockquote><code># 在scheduler_core.py中，由一个提示生成</code><br>
<code>import asyncio</code><br>
<code>from apscheduler.schedulers.asyncio import AsyncIOScheduler</code><br>
<code></code><br>
<code>class MainScheduler:</code><br>
<code>    def __init__(self):</code><br>
<code>        self.scheduler = AsyncIOScheduler()</code><br>
<code></code><br>
<code># ... (16 more lines)</code></blockquote>
<p><em>View full code: <a href="https://gist.github.com/geyuxu/174c72dc6c9e6ddfd46ff80565c762cc">GitHub Gist</a></em></p><p>当运行中的调度器调用<code>handle_failed_task</code>时，它会崩溃并显示<code>RuntimeError: This event loop is already running</code>。AI专注于票务系统的本地上下文，使用了方便的<code>asyncio.run()</code>，不知道它是更大的、已经运行的事件循环的一部分。</p>
<p>此外，选择<code>apscheduler</code>的<code>CronTrigger</code>引入了另一层复杂性。它的阻塞性质和独立的线程模型与我设想的完全异步设计不能很好地融合，导致时序错误和难以调试的竞态条件。</p>
<h3>3. 机器中的幽灵：无监督开发的危险</h3>
<p>我的开发过程是有缺陷的。我把AI当作自主开发者，给它一个功能列表并期望一个连贯的结果。我放弃了作为架构师和审查者的角色。</p>
<p>如果要求人类开发者构建所有这些，他们会反击。他们会要求澄清，提出分阶段推出，并对复杂性提出担忧。AI没有。它只是执行，编织一个纠结的网，没有来自经验的整体理解。没有每一步的定期手动代码审查和集成测试，我对不断积累的架构腐败是盲目的。</p>
<h3>4. 架构纠缠</h3>
<p>最终结果是一个紧密耦合的单体。&quot;自动改进任务生成&quot;模块对<code>TicketingSystem</code>的内部数据结构有直接依赖。<code>MainScheduler</code>知道&quot;智能任务执行&quot;模块工作方式的内部细节。</p>
<p><strong>概念问题：紧密耦合</strong></p>
<blockquote><code># 之前：依赖关系的混乱</code><br>
<code>class MainScheduler:</code><br>
<code>    def __init__(self):</code><br>
<code>        # 调度器直接实例化其&quot;智能&quot;组件</code><br>
<code>        self.improver = AutoTaskImprover()</code><br>
<code>        self.ticketer = TicketingSystem()</code><br>
<code></code><br>
<code>    def _execute_task(self, task):</code><br>
<code># ... (9 more lines)</code></blockquote>
<p><em>View full code: <a href="https://gist.github.com/geyuxu/f88c340b26a46897ec7863eefdba8181">GitHub Gist</a></em></p><p>调试是一场噩梦。一个组件的失败会在整个系统中级联，使得无法隔离根本原因。系统不是一个协作模块的集合；它是一台单一的、脆弱的机器。</p>
<h2>恢复：人机合作的经验教训</h2>
<p>从这个边缘爬回来是一次谦逊的练习，也是回归第一原则。恢复过程给了我一个与AI合作的清晰框架，既能利用其力量又不会屈服于其陷阱。</p>
<h3>经验教训1：拥抱渐进主义（&quot;爬行、行走、奔跑&quot;方法）</h3>
<p>第一步是把它全部拆掉。我重新开始，有一个明确的目标：构建一个坚如磐石的、简单的、异步任务调度器。没有&quot;智能&quot;，没有&quot;自我改进&quot;。只是一个稳定的核心。</p>
<p>只有在这个核心被构建、测试和验证之后，我才开始逐一添加AI功能。每个新功能都被开发为一个独特的、可选的模块，而不是核心组件。</p>
<p><strong>修复：模块化、可插拔架构</strong></p>
<blockquote><code># 之后：使用依赖注入的清洁、解耦设计</code><br>
<code></code><br>
<code># --- 核心调度器（对&quot;智能&quot;功能一无所知）---</code><br>
<code>class MainScheduler:</code><br>
<code>    def __init__(self, plugins=None):</code><br>
<code>        self.plugins = plugins or []</code><br>
<code></code><br>
<code>    def _execute_task(self, task):</code><br>
<code># ... (20 more lines)</code></blockquote>
<p><em>View full code: <a href="https://gist.github.com/geyuxu/073809109d1ea99521b025ba12754a22">GitHub Gist</a></em></p><p>这种方法保持核心清洁，并允许功能被启用、禁用或替换，而不影响系统的其余部分。</p>
<h3>经验教训2：人在回路中是不可协商的</h3>
<p>我把角色从&quot;项目经理&quot;改为&quot;首席架构师和高级开发者&quot;。AI是我聪明但缺乏经验的初级伙伴。我的新工作流程如下：</p>
<ol>
<li><strong>定义一个小的、隔离的任务</strong>（例如，&quot;创建一个插件类，将任务失败记录到JSON文件&quot;）</li>
<li><strong>AI生成代码</strong></li>
<li><strong>我批判性地审查每一行</strong>。我检查反模式、架构不匹配和错误假设。</li>
<li><strong>我自己重构和集成代码</strong>。我是将其连接到主应用程序的人，确保它遵循既定的架构。</li>
<li><strong>我编写集成测试并提交</strong></li>
</ol>
<p>这个以人为中心的循环是我做出的最重要的改变。它让我控制架构和质量。</p>
<h3>经验教训3：简单（仍然）胜过复杂</h3>
<p><code>asyncio</code>问题通过执行一个简单的规则得到解决：只有一个事件循环，它由应用程序的入口点管理。模块和插件绝不能调用<code>asyncio.run()</code>或<code>loop.run_forever()</code>。相反，它们暴露主循环可以<code>await</code>的<code>async</code>函数。</p>
<p><strong>修复：单一、统一的事件循环</strong></p>
<blockquote><code># 在插件文件中（例如，ticketing_plugin.py）</code><br>
<code>class TicketingPlugin:</code><br>
<code>    async def on_task_failed(self, task, result):</code><br>
<code>        # 这个函数现在是异步的，期望被await</code><br>
<code>        await self.create_ticket(task.info)</code><br>
<code></code><br>
<code>    async def create_ticket(self, info):</code><br>
<code>        print(f&quot;为 {info} 创建工单&quot;)</code><br>
<code># ... (18 more lines)</code></blockquote>
<p><em>View full code: <a href="https://gist.github.com/geyuxu/190efc924b5fbf0f1dc0ad434bcc906d">GitHub Gist</a></em></p><p>这个架构原则——简单性——必须由人类开发者执行。AI为本地目标优化，可能不会选择最简单的全局路径。</p>
<h2>最后的思考：飞行员，而不是乘客</h2>
<p>AI开发工具不是你项目的自主驾驶员；它们是极其强大的副驾驶。它们可以处理复杂的机动、处理大量信息，并以超人的速度执行指令。但人类开发者必须保持机长的身份，负责飞行计划（架构）、起飞前检查（代码审查）和旅程的最终方向。</p>
<p>我在Nighthawks的经历教会了我AI的承诺是真实的，但它需要一种新的纪律。我们必须抵制让它无监督运行的诱惑。相反，我们必须指导它、质疑它，并将其输出与只有人类架构师才能提供的智慧和远见相结合。</p>
<p>通过将我们的战略监督与AI的战术能力配对，我们可以避免飞入复杂性的风暴，而是导航建造真正出色的软件。</p>
<h2>关键要点</h2>
<ol>
<li><strong>从简单开始</strong>：在添加智能功能之前构建坚实的基础</li>
<li><strong>人工审查至关重要</strong>：每个AI生成的代码都需要人工架构审查</li>
<li><strong>模块化设计</strong>：保持功能可选和松散耦合</li>
<li><strong>增量开发</strong>：一次添加一个功能并彻底测试</li>
<li><strong>架构很重要</strong>：人类必须保持架构师的身份，而不仅仅是项目经理</li>
</ol>
<p>软件开发的未来不在于用AI替代人类判断，而在于创建一个伙伴关系，其中每个人都贡献他们独特的优势，更快、更可靠地构建更好的软件。</p>

</body>
</html>