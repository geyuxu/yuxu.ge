<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My AI Coding Partner Almost Drove My Project Off a Cliff: A Cautionary Tale</title>
    <style>
        body { font-family: Georgia, serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; line-height: 1.7; color: #333; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        h2 { font-size: 1.4rem; margin-top: 2rem; }
        pre { background: #f4f4f4; padding: 1rem; overflow-x: auto; border-radius: 4px; }
        code { font-family: Menlo, Monaco, monospace; font-size: 0.9em; }
        p code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; }
        img { max-width: 100%; }
        blockquote { border-left: 3px solid #ddd; margin-left: 0; padding-left: 1rem; color: #666; }
        ul { padding-left: 1.5rem; }
        hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        a { color: #1a8917; }
    </style>
</head>
<body>
<hr>
<h2>date: 2025-07-27
tags: [ai, ai, software development, architecture, best practices, asyncio, python]
legacy: true</h2>
<h1>My AI Coding Partner Almost Drove My Project Off a Cliff: A Cautionary Tale</h1>
<ol>
<li><strong>Core Scheduling Engine:</strong> A robust, <code>asyncio</code>-based scheduler.</li>
<li><strong>Intelligent Task Execution:</strong> A system that could analyze task outcomes and dynamically adjust parameters for future runs.</li>
<li><strong>Auto-Improving Task Generation:</strong> A feature where the AI could rewrite a task&#39;s underlying script based on performance metrics or failures.</li>
<li><strong>Human Ticketing System:</strong> When a task failed irrecoverably, the system would generate a &quot;ticket,&quot; which a human could review, annotate with a solution, and feed back into the system&#39;s knowledge base.</li>
</ol>
<p>The AI dutifully churned out code. The ticketing system was built, the self-improvement hooks were added, and the scheduler was wired up. On the surface, it looked like a massive success. The problem was that I was acting as a project manager, not an architect. I was specifying <em>what</em> to build, but I wasn&#39;t rigorously guiding <em>how</em> it was built and integrated.</p>
<h2>The Collision with Reality: Four Horsemen of the AI-pocalypse</h2>
<p>The rapid, un-reviewed development cycle papered over deep-seated issues. When I finally tried to run the integrated system, it collapsed. The root causes were not novel or exotic; they were classic software engineering failures, amplified and accelerated by AI.</p>
<h3>1. The Siren&#39;s Call of Over-engineering</h3>
<p>The AI doesn&#39;t have the business context or architectural foresight to say, &quot;This is too much for one go.&quot; It is an incredibly powerful implementation engine. By asking for everything at once, I had inadvertently directed it to build a solution for a future that didn&#39;t exist yet, ignoring the immediate need for a stable foundation. The &quot;intelligent&quot; features were bolted onto a core that had never been pressure-tested, creating a solution in search of a problem.</p>
<h3>2. The Technical Debt Avalanche</h3>
<p>This is where the theoretical problems became painfully concrete. The AI, in its effort to satisfy all requests, made expedient choices that created fundamental conflicts.</p>
<p>The most glaring issue was the <code>asyncio</code> event loop conflict. Different modules, likely developed in separate AI prompts, were trying to manage the event loop independently. For example, the core scheduler might have been initialized with:</p>
<p><strong>Problematic Code Snippet 1: Conflicting Event Loops</strong></p>
<blockquote><code># In scheduler_core.py, generated by one prompt</code><br>
<code>import asyncio</code><br>
<code>from apscheduler.schedulers.asyncio import AsyncIOScheduler</code><br>
<code></code><br>
<code>class MainScheduler:</code><br>
<code>    def __init__(self):</code><br>
<code>        self.scheduler = AsyncIOScheduler()</code><br>
<code></code><br>
<code># ... (16 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>When <code>handle_failed_task</code> was called by the running scheduler, it would crash with a <code>RuntimeError: This event loop is already running</code>. The AI, focusing on the local context of the ticketing system, used the convenient <code>asyncio.run()</code>, unaware that it was part of a larger, already-running event loop.</p>
<p>Furthermore, the choice of <code>apscheduler</code>&#39;s <code>CronTrigger</code> introduced another layer of complexity. Its blocking nature and separate threading model didn&#39;t mesh cleanly with the fully asynchronous design I envisioned, leading to timing bugs and difficult-to-debug race conditions.</p>
<h3>3. The Ghost in the Machine: The Peril of Unsupervised Development</h3>
<p>My development process was flawed. I was treating the AI as an autonomous developer, giving it a list of features and expecting a coherent result. I had abdicated my role as the architect and reviewer.</p>
<p>A human developer, if asked to build all this, would have pushed back. They would have asked for clarification, proposed a phased rollout, and raised concerns about complexity. The AI did not. It simply executed, weaving a tangled web without the holistic understanding that comes from experience. Without regular, manual code reviews and integration testing at each step, I was blind to the accumulating architectural rot.</p>
<h3>4. The Architectural Tangle</h3>
<p>The end result was a tightly coupled monolith. The &quot;Auto-Improving Task Generation&quot; module had direct dependencies on the <code>TicketingSystem</code>&#39;s internal data structures. The <code>MainScheduler</code> knew intimate details about how the &quot;Intelligent Task Execution&quot; module worked.</p>
<p><strong>Conceptual Problem: Tight Coupling</strong></p>
<blockquote><code># Before: A tangled mess of dependencies</code><br>
<code>class MainScheduler:</code><br>
<code>    def __init__(self):</code><br>
<code>        # The scheduler directly instantiates its &quot;smart&quot; components</code><br>
<code>        self.improver = AutoTaskImprover()</code><br>
<code>        self.ticketer = TicketingSystem()</code><br>
<code></code><br>
<code>    def _execute_task(self, task):</code><br>
<code># ... (9 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>Debugging was a nightmare. A failure in one component would cascade through the system, making it impossible to isolate the root cause. The system was not a collection of cooperating modules; it was a single, fragile machine.</p>
<h2>The Recovery: Lessons for a Human-AI Partnership</h2>
<p>Crawling back from this brink was an exercise in humility and a return to first principles. The recovery process gave me a clear framework for working with AI, one that leverages its power without succumbing to its pitfalls.</p>
<h3>Lesson 1: Embrace Incrementalism (The &quot;Crawl, Walk, Run&quot; Method)</h3>
<p>The first step was to tear it all down. I started again with a single, clear goal: build a rock-solid, simple, asynchronous task scheduler. No &quot;intelligence,&quot; no &quot;self-improvement.&quot; Just a stable core.</p>
<p>Only after this core was built, tested, and proven did I begin to add the AI features back, one by one. Each new feature was developed as a distinct, optional module, not a core component.</p>
<p><strong>The Fix: A Modular, Pluggable Architecture</strong></p>
<blockquote><code># After: A clean, decoupled design using dependency injection</code><br>
<code></code><br>
<code># --- Core Scheduler (knows nothing about &quot;smart&quot; features) ---</code><br>
<code>class MainScheduler:</code><br>
<code>    def __init__(self, plugins=None):</code><br>
<code>        self.plugins = plugins or []</code><br>
<code></code><br>
<code>    def _execute_task(self, task):</code><br>
<code># ... (20 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>This approach keeps the core clean and allows features to be enabled, disabled, or replaced without affecting the rest of the system.</p>
<h3>Lesson 2: The Human-in-the-Loop is Non-Negotiable</h3>
<p>I changed my role from &quot;project manager&quot; to &quot;lead architect and senior developer.&quot; The AI is my brilliant but inexperienced junior partner. My new workflow looks like this:</p>
<ol>
<li><strong>Define a small, isolated task.</strong> (e.g., &quot;Create a plugin class that logs task failures to a JSON file.&quot;)</li>
<li><strong>AI generates the code.</strong></li>
<li><strong>I critically review every line.</strong> I check for anti-patterns, architectural mismatches, and incorrect assumptions.</li>
<li><strong>I refactor and integrate the code myself.</strong> I am the one who connects it to the main application, ensuring it adheres to the established architecture.</li>
<li><strong>I write the integration tests and commit.</strong></li>
</ol>
<p>This human-centric loop is the single most important change I made. It keeps me in control of the architecture and quality.</p>
<h3>Lesson 3: Simple is (Still) Better Than Complex</h3>
<p>The <code>asyncio</code> problem was solved by enforcing a single, simple rule: there is only one event loop, and it is managed by the application&#39;s entry point. Modules and plugins must never call <code>asyncio.run()</code> or <code>loop.run_forever()</code>. Instead, they expose <code>async</code> functions that the main loop can <code>await</code>.</p>
<p><strong>The Fix: A Single, Unified Event Loop</strong></p>
<blockquote><code># In a plugin file (e.g., ticketing_plugin.py)</code><br>
<code>class TicketingPlugin:</code><br>
<code>    async def on_task_failed(self, task, result):</code><br>
<code>        # This function is now async and expects to be awaited</code><br>
<code>        await self.create_ticket(task.info)</code><br>
<code></code><br>
<code>    async def create_ticket(self, info):</code><br>
<code>        print(f&quot;Creating ticket for {info}&quot;)</code><br>
<code># ... (18 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>This architectural principle—simplicity—must be enforced by the human developer. An AI, optimizing for a local goal, may not choose the simplest global path.</p>
<h2>Final Thoughts: The Pilot, Not the Passenger</h2>
<p>AI development tools are not autonomous pilots for your projects; they are incredibly powerful copilots. They can handle complex maneuvers, process vast amounts of information, and execute instructions with superhuman speed. But the human developer must remain the pilot-in-command, responsible for the flight plan (architecture), the pre-flight checks (code reviews), and the ultimate direction of the journey.</p>
<p>My experience with Nighthawks taught me that the promise of AI is real, but it requires a new kind of discipline. We must resist the temptation to let it run unsupervised. Instead, we must guide it, question it, and integrate its output with the wisdom and foresight that only a human architect can provide.</p>
<p>By pairing our strategic oversight with the AI&#39;s tactical prowess, we can avoid flying into a storm of complexity and instead navigate toward building truly remarkable software.</p>
<h2>Key Takeaways</h2>
<ol>
<li><strong>Start Simple</strong>: Build a solid foundation before adding intelligent features</li>
<li><strong>Human Review is Critical</strong>: Every AI-generated code needs human architectural review</li>
<li><strong>Modular Design</strong>: Keep features optional and loosely coupled</li>
<li><strong>Incremental Development</strong>: Add one feature at a time and test thoroughly</li>
<li><strong>Architecture Matters</strong>: The human must remain the architect, not just the project manager</li>
</ol>
<p>The future of software development lies not in replacing human judgment with AI, but in creating a partnership where each contributes their unique strengths to build better software, faster and more reliably.</p>

</body>
</html>