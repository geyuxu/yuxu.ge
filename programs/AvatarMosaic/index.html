<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>在线头像拼图生成 (HTML5)</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: 40px auto;
      line-height: 1.5;
    }
    label {
      display: block;
      margin: 12px 0 6px;
    }
    input[type="range"],
    input[type="number"] {
      width: 100%;
    }
    /* 预览容器：只做边框，不开启横向滚动 */
    .preview-container {
      border: 1px solid #ccc;
      margin-top: 16px;
      padding: 4px;
    }
    #preview {
      display: block;
      max-width: 100%;   /* 根据父元素自动缩放 */
      height: auto;
    }
    button,
    a {
      margin-top: 12px;
      display: inline-block;
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      text-decoration: none;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover,
    a:hover {
      background-color: #45A049;
    }
  </style>
</head>
<body>

  <h1>在线头像拼图生成器</h1>

  <label>选择头像（支持多选）：
    <input type="file" id="fileInput" multiple accept="image/*">
  </label>

  <label>瓦片大小 (像素):
    <input type="range" id="tileSize" min="30" max="150" step="1" value="80">
    <input type="number" id="tileNumber" min="30" max="150" value="80" style="margin-top:4px;">
  </label>

  <label>间距大小 (像素):
    <input type="range" id="gapSize" min="0" max="30" step="1" value="10">
    <input type="number" id="gapNumber" min="0" max="30" value="10" style="margin-top:4px;">
  </label>

  <label>输出宽度 (像素):
    <input type="number" id="outputWidth" value="2560" min="100" step="10">
  </label>

  <label>输出高度 (像素):
    <input type="number" id="outputHeight" value="1440" min="100" step="10">
  </label>

  <button id="generateBtn">生成拼图</button>
  <a id="downloadBtn" style="display:none;" download="mosaic.png">下载 PNG</a>

  <div class="preview-container">
    <img id="preview" src="" alt="生成预览">
  </div>

  <!-- 加载 Pica 的 UMD 版：实现高质量缩放 -->
  <script src="./pica.js"></script>

  <script type="module">
    // 使用全局 pica() 创建实例
    const picaInst = window.pica();

    // 获取 DOM 元素
    const fileInput    = document.getElementById('fileInput');
    const tileSizeRng  = document.getElementById('tileSize');
    const tileSizeNum  = document.getElementById('tileNumber');
    const gapSizeRng   = document.getElementById('gapSize');
    const gapSizeNum   = document.getElementById('gapNumber');
    const outputWNum   = document.getElementById('outputWidth');
    const outputHNum   = document.getElementById('outputHeight');
    const generateBtn  = document.getElementById('generateBtn');
    const downloadBtn  = document.getElementById('downloadBtn');
    const previewImg   = document.getElementById('preview');

    // 同步滑块与数字框
    tileSizeRng.oninput = e => tileSizeNum.value = e.target.value;
    tileSizeNum.oninput = e => tileSizeRng.value = e.target.value;
    gapSizeRng.oninput  = e => gapSizeNum.value = e.target.value;
    gapSizeNum.oninput  = e => gapSizeRng.value = e.target.value;

    // 将 File 对象转换为 ImageBitmap
    async function fileToBitmap(file) {
      return createImageBitmap(file);
    }

    // 裁剪为正方形再缩放到 size×size：返回 OffscreenCanvas
    async function cropAndResize(bmp, size) {
      const w = bmp.width, h = bmp.height;
      const s = Math.min(w, h);
      const sx = Math.floor((w - s) / 2);
      const sy = Math.floor((h - s) / 2);

      // 离屏 Canvas 裁剪
      const off = new OffscreenCanvas(s, s);
      const ctxOff = off.getContext('2d');
      ctxOff.drawImage(bmp, sx, sy, s, s, 0, 0, s, s);

      // 离屏 Canvas 高质量缩放到 size×size
      const target = new OffscreenCanvas(size, size);
      await picaInst.resize(off, target, {
        unsharpAmount: 80,
        transferable: true
      });
      return target;
    }

    /**
     * 根据 bitmaps（ImageBitmap 数组）、tile/gap/outW/outH，
     * 生成最终拼图，返回 OffscreenCanvas。
     */
    async function buildMosaic(bitmaps, tile, gap, outW, outH) {
      const N = bitmaps.length;
      // 1. 搜索行数 rows，使 cols = ceil(N/rows)，并且比例接近 16:9
      let best = null;
      const targetRatio = 16 / 9;
      const tol = 0.5;  
      const maxRows = Math.min(Math.ceil(Math.sqrt(N)) * 2, 200);

      for (let rows = 1; rows <= maxRows; rows++) {
        const cols = Math.ceil(N / rows);
        // 只在列之间留 gap，不在左右两侧留：
        const clusterW = cols * tile + (cols - 1) * gap;  
        const clusterH = rows * tile + (rows - 1) * gap;  
        const ratio = clusterW / clusterH;
        const diff = Math.abs(ratio - targetRatio);
        if (diff > tol) continue;
        if (!best || diff < best.diff) {
          best = { diff, rows, cols, clusterW, clusterH };
        }
      }

      if (!best) {
        throw new Error('无法找到满足比例的布局，请调整瓦片大小或间距');
      }

      const { rows, cols, clusterW, clusterH } = best;
      console.log(`最佳布局 → rows=${rows}, cols=${cols}, tile=${tile}, gap=${gap}, cluster=${clusterW}×${clusterH}`);

      // 2. 计算需要补充的头像数量，并均匀打散
      const totalSlots = rows * cols;
      const extra = totalSlots - N;
      const fullList = bitmaps.slice();
      if (extra > 0) {
        let pool = [];
        const times = Math.ceil(extra / N);
        for (let i = 0; i < times; i++) {
          pool = pool.concat(bitmaps);
        }
        // 使用 Fisher-Yates 随机打乱
        for (let i = pool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        fullList.push(...pool.slice(0, extra));
      }

      // 3. 在离屏 Canvas 上绘制拼图
      const mosaicOff = new OffscreenCanvas(clusterW, clusterH);
      const mctx = mosaicOff.getContext('2d');
      mctx.clearRect(0, 0, clusterW, clusterH);

      for (let idx = 0; idx < totalSlots; idx++) {
        const bmp = fullList[idx];
        // 裁剪 & 缩放
        const smallOff = await cropAndResize(bmp, tile);
        const r = Math.floor(idx / cols);
        const c = idx % cols;
        // dx, dy 不再加额外 gap，只在每个 tile 间留 gap：
        const dx = c * (tile + gap);
        const dy = r * (tile + gap);
        mctx.drawImage(smallOff, dx, dy);
      }

      /* ---------- 4. 先缩放到同尺寸临时画布，再一次性贴到最终画布 ---------- */
      const scale = Math.min(outW / clusterW, outH / clusterH);
      const newW  = Math.floor(clusterW * scale);
      const newH  = Math.floor(clusterH * scale);
      const offsetX = Math.floor((outW - newW) / 2);
      const offsetY = Math.floor((outH - newH) / 2);
      
      // 4-a：临时画布，尺寸正好 = newW × newH
      const scaledOff = new OffscreenCanvas(newW, newH);
      await picaInst.resize(mosaicOff, scaledOff);   // 填满整个 scaledOff
      
      // 4-b：把 scaledOff 居中绘制到最终输出画布
      const finalOff = new OffscreenCanvas(outW, outH);
      const fctx = finalOff.getContext('2d');
      fctx.clearRect(0, 0, outW, outH);
      fctx.drawImage(scaledOff, offsetX, offsetY);

      return finalOff;
    }

    // 点击“生成拼图”按钮时触发
    generateBtn.addEventListener('click', async () => {
      // 先按文件名做“自然顺序”排序
      const files = [...fileInput.files].sort((a, b) =>
        a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' })
      );
      if (files.length === 0) {
        alert('请先选择至少一张图片');
        return;
      }

      generateBtn.textContent = '生成中…';
      generateBtn.disabled = true;
      downloadBtn.style.display = 'none';
      previewImg.src = '';

      try {
        // 1. 将所有选中文件转换为 ImageBitmap
        const bitmaps = await Promise.all(files.map(f => fileToBitmap(f)));

        // 2. 从表单获取参数
        const tile = parseInt(tileSizeNum.value, 10);
        const gap  = parseInt(gapSizeNum.value, 10);
        const outW = parseInt(outputWNum.value, 10);
        const outH = parseInt(outputHNum.value, 10);

        // 3. 调用 buildMosaic 生成拼图 OffscreenCanvas
        const finalCanvas = await buildMosaic(bitmaps, tile, gap, outW, outH);

        // 4. 导出 PNG Blob，预览并生成下载链接
        const blob = await finalCanvas.convertToBlob({ type: 'image/png' });
        const url = URL.createObjectURL(blob);
        previewImg.src = url;
        downloadBtn.href = url;
        downloadBtn.style.display = 'inline-block';
      } catch (err) {
        alert('生成失败：' + err);
        console.error(err);
      } finally {
        generateBtn.textContent = '生成拼图';
        generateBtn.disabled = false;
      }
    });
  </script>
</body>
</html>