<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>为个人网站构建 RAG 驱动的 AI 助手</title>
    <style>
        body { font-family: Georgia, serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; line-height: 1.7; color: #333; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        h2 { font-size: 1.4rem; margin-top: 2rem; }
        pre { background: #f4f4f4; padding: 1rem; overflow-x: auto; border-radius: 4px; }
        code { font-family: Menlo, Monaco, monospace; font-size: 0.9em; }
        p code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; }
        img { max-width: 100%; }
        blockquote { border-left: 3px solid #ddd; margin-left: 0; padding-left: 1rem; color: #666; }
        ul { padding-left: 1.5rem; }
        hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        a { color: #1a8917; }
    </style>
</head>
<body>
<hr>
<h2>date: 2026-01-28
tags: [ai, rag, cloudflare-workers, javascript, llm]
description: 使用混合搜索、Cloudflare Workers 和 OpenAI API 为个人网站构建 RAG 驱动的 AI 助手。</h2>
<h1>为个人网站构建 RAG 驱动的 AI 助手</h1>
<p>最近我为个人网站添加了一个 AI 聊天助手，它可以回答关于博客文章、项目和个人背景的问题。本文记录了从架构设计到安全考虑的完整实现过程。</p>
<h2>目标</h2>
<p>创建一个浮动聊天组件：</p>
<ul>
<li>使用 RAG（检索增强生成）回答博客相关问题</li>
<li>提供友好的技术交流</li>
<li>优雅地处理敏感话题</li>
<li>完全运行在静态托管（GitHub Pages）上，使用 Cloudflare Workers 作为 API 层</li>
</ul>
<h2>架构概览</h2>
<blockquote><code>┌─────────────────────────────────────────────────────────────────┐</code><br>
<code>│                        浏览器（前端）                            │</code><br>
<code>├─────────────────────────────────────────────────────────────────┤</code><br>
<code>│  聊天组件 ──────▶ 搜索客户端                                     │</code><br>
<code>│       │          ├─ BM25 关键词搜索（本地）                      │</code><br>
<code>│       │          └─ Voy WASM 语义搜索                           │</code><br>
<code>│       │                    │                                    │</code><br>
<code>│       │◀───────────────────┘ （Top 3 片段作为上下文）            │</code><br>
<code># ... (17 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><h2>实现细节</h2>
<h3>1. 聊天组件（前端）</h3>
<p>聊天组件是一个独立的 JavaScript 模块，创建浮动气泡 UI：</p>
<blockquote><code>export class ChatWidget {</code><br>
<code>    constructor() {</code><br>
<code>        this.messages = [];</code><br>
<code>        this.isOpen = false;</code><br>
<code>        this.searchClient = null;</code><br>
<code>    }</code><br>
<code></code><br>
<code>    async sendMessage(text) {</code><br>
<code># ... (21 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>主要特性：</p>
<ul>
<li><strong>Markdown 渲染</strong>：将 <code>**粗体**</code> 和 <code>[链接](url)</code> 转换为 HTML</li>
<li><strong>CSS-in-JS</strong>：所有样式动态注入，无外部依赖</li>
<li><strong>ESC 关闭</strong>：键盘可访问性</li>
<li><strong>移动端适配</strong>：响应式布局</li>
</ul>
<h3>2. 混合搜索实现 RAG</h3>
<p>我已有一套搜索系统：</p>
<ul>
<li><strong>BM25 关键词搜索</strong>：本地倒排索引，精确词项匹配</li>
<li><strong>Voy WASM 语义搜索</strong>：使用预计算 embeddings 的向量相似度</li>
<li><strong>RRF 融合</strong>：使用 Reciprocal Rank Fusion 合并两路结果</li>
</ul>
<p>聊天组件复用这套现有基础设施：</p>
<blockquote><code>const [keywordResults, semanticResults] = await Promise.all([</code><br>
<code>    this.keywordSearch(query, limit * 2),</code><br>
<code>    this.semanticSearch(query, limit * 2),</code><br>
<code>]);</code><br>
<code></code><br>
<code>// 使用 RRF 合并</code><br>
<code>for (const result of keywordResults) {</code><br>
<code>    rrfScores[result.url] = keywordWeight / (k + result.rank);</code><br>
<code>}</code><br>
<code>for (const result of semanticResults) {</code><br>
<code>    rrfScores[result.url] += semanticWeight / (k + result.rank);</code><br>
<code>}</code></blockquote><h3>3. Cloudflare Worker（API 代理）</h3>
<p>Worker 处理两个端点：</p>
<p><strong><code>/api/embedding</code></strong> - 将查询文本转换为向量用于语义搜索：</p>
<blockquote><code>const response = await fetch(&#039;https://api.openai.com/v1/embeddings&#039;, {</code><br>
<code>    method: &#039;POST&#039;,</code><br>
<code>    headers: {</code><br>
<code>        &#039;Authorization&#039;: `Bearer ${env.OPENAI_API_KEY}`,</code><br>
<code>        &#039;Content-Type&#039;: &#039;application/json&#039;,</code><br>
<code>    },</code><br>
<code>    body: JSON.stringify({</code><br>
<code>        model: &#039;text-embedding-3-small&#039;,</code><br>
<code>        input: text,</code><br>
<code>        dimensions: 512,</code><br>
<code>    }),</code><br>
<code>});</code></blockquote><p><strong><code>/api/chat</code></strong> - 带 RAG 上下文的聊天补全：</p>
<blockquote><code>const systemMessage = context</code><br>
<code>    ? `${env.system_prompt}\n\n## 相关博客内容：\n${context}`</code><br>
<code>    : env.system_prompt;</code><br>
<code></code><br>
<code>const response = await fetch(&#039;https://api.openai.com/v1/chat/completions&#039;, {</code><br>
<code>    method: &#039;POST&#039;,</code><br>
<code>    headers: { &#039;Authorization&#039;: `Bearer ${env.OPENAI_API_KEY}` },</code><br>
<code>    body: JSON.stringify({</code><br>
<code>        model: &#039;gpt-4o-mini&#039;,</code><br>
<code>        messages: [</code><br>
<code>            { role: &#039;system&#039;, content: systemMessage },</code><br>
<code>            ...messages,</code><br>
<code>        ],</code><br>
<code>    }),</code><br>
<code>});</code></blockquote><h3>4. 安全考虑：敏感话题处理</h3>
<p>对于个人网站，我需要助手能够：</p>
<ul>
<li>自由讨论网站主人（我自己）</li>
<li>优雅地拒绝政治/敏感话题</li>
</ul>
<p>这通过 system prompt（存储为环境变量）实现：</p>
<blockquote><code>## 关于网站主人</code><br>
<code>Yuxu Ge（葛于旭）是网站的主人，你可以自由讨论：</code><br>
<code>- 职业背景、技术经历、项目作品</code><br>
<code>- 博客内容、技术观点</code><br>
<code>- 公开的个人信息（教育、工作经历等）</code><br>
<code></code><br>
<code>## 对话边界</code><br>
<code>对以下话题礼貌拒绝并引导：</code><br>
<code># ... (10 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><h3>5. 使用 localStorage 实现对话历史</h3>
<p>为了更好的用户体验，聊天组件将对话历史持久化到浏览器的 localStorage：</p>
<blockquote><code>const CHAT_CONFIG = {</code><br>
<code>    storageKey: &#039;chat_history&#039;,</code><br>
<code>    historyTTL: 24 * 60 * 60 * 1000, // 24 小时</code><br>
<code>};</code><br>
<code></code><br>
<code>// 每次成功响应后保存</code><br>
<code>saveHistory() {</code><br>
<code>    const data = {</code><br>
<code># ... (22 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>功能特性：</p>
<ul>
<li><strong>自动保存</strong>：每次助手响应后保存</li>
<li><strong>自动恢复</strong>：页面加载时恢复对话</li>
<li><strong>24小时过期</strong>：自动清除过期对话</li>
<li><strong>手动清除</strong>：头部垃圾桶按钮可手动清空</li>
</ul>
<p>选择 localStorage 而非服务端存储（Cloudflare KV）的原因：</p>
<ul>
<li>大多数访客是一次性对话</li>
<li>无需用户身份识别</li>
<li>零额外成本</li>
<li>实现更简单</li>
</ul>
<h2>经验总结</h2>
<ol>
<li><p><strong>环境变量优于硬编码</strong>：将 <code>system_prompt</code> 存储为 Cloudflare 环境变量，允许在不部署代码的情况下迭代 prompt。</p>
</li>
<li><p><strong>复用现有搜索基础设施</strong>：在现有混合搜索系统上构建 RAG 节省了大量工作。</p>
</li>
<li><p><strong>细粒度内容过滤</strong>：初始的敏感话题过滤过于激进（连关于我自己的问题都被屏蔽了）。关键是明确<strong>白名单</strong>允许的话题。</p>
</li>
<li><p><strong>聊天中的 Markdown</strong>：简单的正则表达式 Markdown 解析对于粗体和链接已经足够，不需要重型库。</p>
</li>
<li><p><strong>状态管理从简单开始</strong>：localStorage 对于对话历史已经足够。服务端存储（KV）增加复杂度，但对个人网站没有明显收益。</p>
</li>
</ol>
<h2>成本分析</h2>
<p>使用 <code>gpt-4o-mini</code> 和 <code>text-embedding-3-small</code>：</p>
<ul>
<li>Embedding：每次查询约 $0.00002</li>
<li>Chat：每次响应约 $0.0001-0.0005（取决于上下文长度）</li>
<li>预估月费用：中等流量 &lt; $5</li>
</ul>
<h2>后续计划</h2>
<ul>
<li><input disabled="" type="checkbox"> 添加流式响应以提升用户体验</li>
<li><input checked="" disabled="" type="checkbox"> <del>使用存储实现对话记忆</del>（已用 localStorage 实现）</li>
<li><input disabled="" type="checkbox"> 添加使用统计</li>
<li><input disabled="" type="checkbox"> 支持图片理解（博客截图）</li>
</ul>
<p>完整实现已开源在我的网站仓库中，欢迎参考和改造！</p>

</body>
</html>