<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>结合RPG Maker与OpenAI API，打造创意十足的动态角色扮演游戏 | Yuxu Ge</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --black: #111;
            --dark-grey: #444;
            --off-white: #f4f4f4;
            --vermilion: #C41E3A;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--black);
            background-color: var(--off-white);
        }

        a { color: var(--vermilion); text-decoration: none; }
        a:hover { opacity: 0.75; }

        .layout { min-height: 100vh; }

        /* Sidebar */
        .sidebar {
            position: fixed; top: 0; left: 0;
            width: 320px; height: 100vh;
            background: var(--black); color: var(--off-white);
            padding: 3rem 2rem;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .sidebar-top { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .avatar { display: block; width: 120px; height: 120px; border-radius: 50%; border: 3px solid var(--vermilion); margin-bottom: 1.5rem; overflow: hidden; transition: transform 0.2s ease; }
        .avatar:hover { opacity: 1; transform: scale(1.05); }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .name-block { margin-bottom: 0.5rem; }
        h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: 1px; color: var(--off-white); }
        .title-role { font-size: 0.9rem; color: #888; margin-top: 0.25rem; font-weight: 400; }
        .contact-block { margin-top: 2.5rem; width: 100%; }
        .social-links { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .social-links a { display: flex; align-items: center; gap: 0.75rem; width: 160px; color: var(--off-white); opacity: 0.7; padding: 0.5rem 0.75rem; border-radius: 4px; font-size: 0.9rem; transition: all 0.2s; }
        .social-links a:hover { color: var(--vermilion); opacity: 1; background: rgba(255,255,255,0.05); }
        .social-links svg { width: 20px; height: 20px; flex-shrink: 0; }
        .social-links .orcid-link { font-size: 0.68rem; gap: 0.5rem; white-space: nowrap; }
        .sidebar-footer { text-align: center; font-size: 0.75rem; color: #555; }

        /* Content */
        .content { margin-left: 320px; padding: 3rem 4rem; max-width: 900px; }
        .back-link { display: inline-block; font-size: 0.85rem; margin-bottom: 2rem; color: var(--dark-grey); }
        .back-link:hover { color: var(--vermilion); }

        /* Article */
        article h1 { font-size: 2rem; font-weight: 700; margin-bottom: 1.5rem; line-height: 1.3; color: var(--black); }
        article h2 { font-size: 1.4rem; font-weight: 600; margin: 2rem 0 1rem; color: var(--black); }
        article h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; color: var(--black); }
        article p { margin-bottom: 1rem; color: var(--dark-grey); }
        article ul, article ol { margin: 1rem 0 1rem 1.5rem; color: var(--dark-grey); }
        article li { margin-bottom: 0.5rem; }
        article strong { color: var(--black); }
        article code { font-family: "SF Mono", Monaco, monospace; font-size: 0.9em; background: #e8e8e8; padding: 0.15em 0.4em; border-radius: 3px; }
        article pre { margin: 1rem 0; border-radius: 6px; overflow-x: auto; background: #2d2d2d; padding: 1rem; }
        article pre code { background: none; padding: 0; font-size: 0.75em; white-space: pre !important; counter-reset: line; display: block; color: #ccc; }
        article pre code .line { counter-increment: line; }
        article pre code .line::before { content: counter(line); display: inline-block; width: 2.5em; margin-right: 1em; text-align: right; color: #666; user-select: none; }
        .code-toolbar { display: flex; justify-content: flex-start; padding: 0.35rem 0.5rem; background: #3a3a3a; border-radius: 6px 6px 0 0; }
        .code-toolbar + pre { margin-top: 0; border-radius: 0 0 6px 6px; }
        .copy-btn { padding: 0.2rem 0.5rem; font-size: 0.7rem; background: #555; color: #fff; border: none; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
        .copy-btn:hover, .copy-btn:active { background: #777; }
        .copy-btn.copied { background: #2a2; }
        article blockquote { border-left: 3px solid var(--vermilion); padding-left: 1rem; margin: 1rem 0; color: #666; font-style: italic; }
        article hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        article table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        article th, article td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
        article th { background: #e8e8e8; font-weight: 600; }
        article img { max-width: 100%; height: auto; display: block; margin: 1.5rem 0; border-radius: 6px; }

        .loading { text-align: center; padding: 3rem; color: #888; }
        .error { color: var(--vermilion); }

        /* KaTeX math styles */
        .katex-display { overflow-x: auto; overflow-y: hidden; padding: 0.5rem 0; }
        .katex { font-size: 1.1em; }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { position: relative; width: 100%; height: auto; padding: 2rem 1.5rem 1rem; }
            .social-links { flex-direction: row; flex-wrap: wrap; justify-content: center; }
            .social-links a, .social-links .orcid-link { width: auto; padding: 0.5rem; font-size: 0; gap: 0; }
            .social-links svg { width: 24px; height: 24px; }
            .social-links .hide-mobile { display: none; }
            .sidebar-footer { margin-top: 1rem; }
            .content { margin-left: 0; padding: 2rem 1rem; }
        }
        @media (max-width: 480px) {
            .sidebar { padding: 1.5rem 1rem 1rem; }
            .avatar { width: 80px; height: 80px; }
            h1 { font-size: 1.4rem; }
            article h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="layout">
    <aside class="sidebar" id="sidebar-content"></aside>
    <script src="/components/sidebar.js"></script>

    <main class="content">
        <a href="/blog/" class="back-link">← Back to Blog</a>
        <article>
<hr>
<h2>date: 2025-02-28
tags: [ai]
legacy: true</h2>
<h1>结合RPG Maker与OpenAI API，打造创意十足的动态角色扮演游戏</h1>
<p>将RPG Maker与OpenAI API相结合，可以开发出前所未有的动态游戏体验。通过引入AI来生成内容，游戏世界不再局限于设计者的预设，而能根据玩家的操作和输入即时改变。下面我们来看看这种集成能够带来哪些具体优势：</p>
<ul>
<li>故事生成：借助OpenAI的强大生成能力，开发者只需提供一个简短的世界观设定或剧情开头，AI就能接力创造出丰富多彩的剧情走向、角色背景、任务描述，甚至即兴的对话台词。每次游戏都可以演绎出不同的故事细节，让每个玩家体验到独一无二的冒险，极大增强游戏的新鲜感和重玩价值。</li>
<li>动态对话系统：传统RPG中的NPC对白通常是固定的，而通过接入OpenAI API，NPC的对话将不再局限于脚本。游戏可以实时将玩家的提问发送给AI，根据上下文生成NPC的回应，实现场景化的自由对话。NPC因此仿佛拥有了“思考”能力，能针对玩家不同的发问给出个性化回答。更进一步地，如果保留对话的上下文，玩家可以与NPC展开多轮对话——NPC会“记住”之前交谈的内容，使对话连贯且富有逻辑，提高玩家的沉浸感。</li>
<li>游戏教程和帮助：在游戏过程中，玩家难免会遇到困惑或瓶颈。通过引入ChatGPT这样的AI，我们可以为游戏添加一个智能帮助系统。当玩家向游戏内的“指南精灵”或帮助菜单提出问题时，AI可以根据游戏当前的进度和上下文，生成针对性的解答或提示。这就好比在游戏中内置了一个实时的攻略客服，随时为玩家排忧解难，提升新手友好度和游戏体验。</li>
<li>智能NPC：除了对话之外，AI还能让NPC变得更“聪明”。NPC可以根据玩家以往的行为模式来调整对玩家的态度和互动。例如，如果玩家多次帮助村民，AI可以让该村民NPC表现出感激，甚至动态赠予额外的礼物或任务；相反，如果玩家做了很多恶行，NPC的对话和行为也会随之改变，可能变得冷淡甚至敌对。通过OpenAI API，开发者可以让NPC实时分析游戏状态并生成合理的反应逻辑，使NPC形象更加立体鲜活。</li>
<li>自适应剧情和难度：每个玩家的游戏风格不同，AI可以根据玩家的选择动态调整游戏的剧情分支和难度曲线。例如，当AI检测到玩家总是喜欢探索支线剧情时，可以生成更多有趣的支线任务；如果玩家在战斗中节节取胜，AI可以提高后续敌人的AI或属性增强挑战性，反之亦然。甚至游戏的结局也可以由AI根据玩家的所作所为来决定，真正做到“你的选择塑造你的故事”。这种自适应机制确保游戏对新手友好，同时也能满足高手对挑战的追求。</li>
</ul>
<h2>快速构建原型 Demo 的步骤</h2>
<p>要想实际体验将AI融入RPG游戏的魅力，我们可以尝试先做一个小型的原型Demo。以下是一个基本的实现流程：</p>
<ol>
<li>准备工作：首先，确保你已安装最新版本的RPG Maker（如RPG Maker MV或MZ），因为这些版本使用JavaScript作为脚本语言，方便与Web API交互。此外，前往OpenAI官方网站注册账号，并创建API密钥（API Key）。这个密钥用于认证你的请求，有了它才能调用OpenAI的接口。在开始编程之前，建议先熟悉一下OpenAI API的基本用法和文档说明，了解请求格式和返回结果结构。</li>
<li>创建RPG Maker项目：打开RPG Maker，新建一个空白项目。为了简化流程，我们只需制作一个小村庄或房间的场景，放置几个人物。使用RPG Maker提供的默认素材快速铺设地形，并添加一个NPC角色（可以用默认的村民角色图像）。再确保有一个玩家起始位置。这个场景将作为我们测试AI对话的舞台。简单的环境即可，无需耗费太多时间美化地图——我们的重点是功能验证。</li>
<li>编写脚本以集成 OpenAI API：接下来，我们需要编写代码让游戏能够和OpenAI的服务器通信。在RPG Maker MV/MZ中，你可以通过编写**插件（Plugin）**的方式加入自定义JavaScript代码。实际上，插件就是扩展游戏引擎功能的JS脚本。创建一个新的JavaScript文件（例如OpenAIChat.js），将其放入项目的js/plugins目录，然后在RPG Maker的插件管理器中启用它。
在这个脚本中，我们编写与OpenAI API交互的逻辑。基本思路是：当需要AI生成内容时，构造好请求（包括提示信息或对话上下文），使用网络请求将其发送给OpenAI的API接口，然后等待并处理返回的结果。在NW.js环境下（RPG Maker运行游戏时的底层环境，相当于一个带Node功能的浏览器），我们可以使用fetch函数或XHR来发送HTTP请求。
下面是一段使用fetch调用OpenAI Chat Completion接口的示例代码：</li>
</ol>
<pre><code class="language-js"><span class="line">const apiKey = &quot;YOUR_OPENAI_API_KEY&quot;;  // 替换为你的实际API密钥</span>
<span class="line">const url = &quot;https://api.openai.com/v1/chat/completions&quot;;</span>
<span class="line">const data = {</span>
<span class="line">    model: &quot;gpt-3.5-turbo&quot;,</span>
<span class="line">    messages: [</span>
<span class="line">        { role: &quot;system&quot;, content: &quot;你是这个游戏世界中博学的NPC村长，用简短语句回答玩家的问题。&quot; },</span>
<span class="line">        { role: &quot;user&quot;, content: &quot;玩家：你好，请问这个村子里有什么有趣的传闻吗？&quot; }</span>
<span class="line">    ]</span>
<span class="line">};</span>
<span class="line">fetch(url, {</span>
<span class="line">    method: &quot;POST&quot;,</span>
<span class="line">    headers: {</span>
<span class="line">        &quot;Content-Type&quot;: &quot;application/json&quot;,</span>
<span class="line">        &quot;Authorization&quot;: `Bearer ${apiKey}`</span>
<span class="line">    },</span>
<span class="line">    body: JSON.stringify(data)</span>
<span class="line">})</span>
<span class="line">.then(response =&gt; response.json())</span>
<span class="line">.then(result =&gt; {</span>
<span class="line">    const reply = result.choices[0].message.content;</span>
<span class="line">    console.log(&quot;NPC:&quot;, reply);</span>
<span class="line">    // 在这里可以将reply内容传递给游戏内变量或直接显示出来</span>
<span class="line">})</span>
<span class="line">.catch(error =&gt; {</span>
<span class="line">    console.error(&quot;Error with OpenAI API:&quot;, error);</span>
<span class="line">});</span></code></pre>
<p>上面这段代码向OpenAI的服务器发送了一条对话：我们设定system角色提示AI扮演村长NPC，并提供了user角色的一句话（模拟玩家的提问），然后模型会生成NPC（assistant角色）的回答。fetch请求得到结果后，我们提取reply并打印在控制台。在实际游戏中，我们不会用console.log，而是要将reply显示给玩家。例如，可以调用RPG Maker的接口将文本加入对话框，或者先存入一个游戏变量，再通过“显示文字”事件命令把变量内容展示出来。
小提示：因为网络请求是异步的，直接在事件中调用上面的代码时，游戏不会等待结果就继续执行后面的命令。为了解决这个问题，可以在收到回复后，通过回调函数或Promise.then来触发后续的对话显示。也可以在NPC说话前先显示一条“…思考中”的消息以过渡等待时间。</p>
<p>如果你更熟悉Python，也可以在开发时使用Python脚本测试OpenAI接口。利用OpenAI提供的Python库，几行代码就能完成与上述JS代码等价的操作，例如：</p>
<pre><code class="language-py"><span class="line">import openai</span>
<span class="line">openai.api_key = &quot;YOUR_OPENAI_API_KEY&quot;</span>
<span class="line">response = openai.ChatCompletion.create(</span>
<span class="line">    model=&quot;gpt-3.5-turbo&quot;,</span>
<span class="line">    messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，有什么有趣的任务可以给我吗？&quot;}]</span>
<span class="line">)</span>
<span class="line">reply = response.choices[0].message.content</span>
<span class="line">print(reply)</span></code></pre>
<p>无论使用哪种语言，实现的关键都是：构造请求 -&gt; 发送请求 -&gt; 接收并处理回复。确保你的请求数据格式符合OpenAI API要求，例如Chat Completion需要一个messages列表。拿到回复后，要根据游戏需要进行处理，比如截断过长的回复、去除不合适的内容等。API返回的内容是字符串，可以直接在游戏对话框中显示。</p>
<ul>
<li><ol start="4">
<li>在游戏事件中调用AI功能：脚本写好后，我们就可以把它融入游戏流程中了。以动态对话为例，我们希望玩家和NPC交互时触发AI对话。具体实现方式是：打开RPG Maker的事件编辑器，找到刚才添加的NPC事件。在NPC的对话事件里，插入一个“脚本”命令或插件命令，调用我们在步骤3中编写的函数。例如，如果我们在插件中封装了一个函数callOpenAI(prompt)用于请求对话，可以传入玩家的提问作为参数。当脚本执行后，暂存AI的回答，然后通过后续的“显示文字”命令将回答呈现出来。举个简单的方法：可以预先在数据库中预留一个变量，比如变量编号1，用于存储AI回复。在脚本拿到reply后，执行$gameVariables.setValue(1, reply)将内容存入变量1。接着在事件里插入一个“显示文字”的指令，内容填入\V[1]，RPG Maker会将其替换为变量1的字符串值，从而显示出AI生成的对话文本。
值得注意的是，如果需要让玩家自由输入问题（而不仅仅是固定选择），RPG Maker默认并没有提供直接输入文本的对话框。你可能需要借助插件实现文本输入，或者退而求其次，用菜单选项让玩家选择提问内容。不过，在原型阶段，我们也可以简化处理，例如每次对话由NPC先问玩家一个问题，然后根据玩家选择的选项去构造不同的提示给AI，从而得到相应回答。</li>
</ol>
</li>
<li><ol start="5">
<li>测试和调试：现在运行游戏，和NPC对话，看看效果如何。第一次集成可能不会一蹴而就，所以需要反复测试和调试。如果NPC没有回应，或者游戏卡住了，可以打开调试控制台（在游戏窗口按下F12，在Console面板查看日志）找出问题。例如，检查API请求是否成功发出，回复数据是否正确返回。常见问题可能包括：API密钥不正确或遗漏、网络请求被拦截（注意本地运行时可能有跨域问题，需要确保NW.js允许网络通信）、返回内容太长超出变量长度导致显示不完整等。根据调试结果，适当调整代码逻辑。
此外，你还可以针对对话内容进行微调。例如修改提示词，使NPC的语气更符合角色性格；或者限制回复长度，避免AI一下子讲个没完。在调试阶段多尝试不同提问，看看NPC的回答是否合理。一旦功能跑通且效果满意，我们的原型Demo就基本完成了！</li>
</ol>
</li>
</ul>
<h2>示例：实现动态对话系统</h2>
<p>上述原型步骤中，我们选择实现NPC的动态对话作为切入点。下面通过一个简单示例，再次梳理如何让NPC基于OpenAI生成对话回应：</p>
<ul>
<li>步骤1：创建NPC交互事件：在地图场景中，选中我们的NPC村长，打开事件编辑器。将事件的触发设置为“与玩家交谈”（即玩家按下确定键触发）。在事件内容中，我们可以先加入一段NPC开场白，比如：“村长：您好，年轻的冒险者，有什么我可以帮你的？”（这句可以是固定的，作为对话的引子）。</li>
<li>步骤2：获取玩家输入并发送请求：紧接着，我们需要获取玩家的问题。这里假设玩家可以通过某种方式提出一个问题（比如我们提供几个选项供玩家选择提问内容，或者更进阶地弹出一个输入框让玩家自由输入）。当玩家的问题确定后，我们调用之前编写的脚本函数，与OpenAI API交互。事件编辑器中插入一个“脚本”命令，例如调用callOpenAI(playerQuestion)，将玩家的问题字符串传递进去。脚本会将问题打包成请求发送给OpenAI，并等待返回NPC的回答。</li>
<li>步骤3：显示AI生成的NPC回答：脚本拿到OpenAI的回复后，会通过我们预先设定的方式将回答注入游戏。例如，脚本内将回答存入变量1。现在在事件编辑器中，我们添加一个“显示文字”命令，用于呈现NPC的回答，内容填写\V[1]（即显示变量1的值）。由于这一系列操作可能需要一瞬间时间，不妨在调用API和显示答案之间加一个短暂的延迟或者过渡提示，例如显示“村长沉思片刻…”。当AI的回复准备好后，玩家将看到NPC基于他提问内容而给出的回应。</li>
<li>步骤4：测试与优化对话效果：运行游戏，触发与村长NPC的对话事件。你会发现，每当你选择不同的提问，村长给出的回答也各不相同，而且不是简单的预设句子，而是AI根据上下文生成的自然语言。例如：
玩家：这个村子最近有没有发生什么奇怪的事？
村长（AI生成）：嗯，让我想想。最近村子北边的森林里总在夜里出现奇怪的蓝光，据说那是精灵在嬉戏，但也有人说可能藏着宝藏。
玩家：有关于魔王的传闻吗？
村长（AI生成）：魔王的传闻倒是久远的很。据我祖父说，百年前这里的人们曾联手击败过一位魔王的爪牙。不过最近倒是风平浪静，年轻人不用过于担心。
从上面的对话可以看到，借助AI，NPC能够根据玩家提出的不同问题给出合理而丰富的回答，仿佛真的拥有自己的记忆和见识。如果觉得某些回答不符合预期，我们可以调整提示词（让村长语气更严谨或幽默），或者在玩家提问中附加更多背景信息以获得更相关的回复。经过多次迭代优化，我们的动态对话系统将变得更加自然好玩。</li>
</ul>
<h2>拓展：更多AI创意玩法探索</h2>
<p>除了本文实现的动态对话外，结合RPG Maker和OpenAI API还可以创造出更多新奇有趣的玩法。以下是几个值得尝试的思路：</p>
<ul>
<li>动态剧情和支线任务生成：让AI承担部分“编剧”职责，根据游戏进程动态生成新的剧情段落或支线任务。例如，当玩家抵达某个阶段时，调用AI根据当前世界状态生成一个全新的任务描述：“镇长请求你去调查最近袭击村庄的神秘生物”。AI甚至可以为这个任务即兴创作一个小故事背景和不同的完成方式。每次游玩时，玩家遇到的任务可能都不同，游戏因此拥有无限的新鲜内容。</li>
<li>多轮对话与长期记忆：在前面的示例中，我们实现了NPC在一次对话中的即时回应。更进一步，可以让NPC拥有对话的“长期记忆”。通过在每次对话时将之前的重要交互摘要传递给AI，NPC就能记住玩家曾经透露的信息或做出的承诺。这样，当玩家第二次与同一NPC对话时，NPC能提及上次交谈的内容（“上回你说想成为剑士，不知你训练得如何了？”），营造出持续互动的真实感。实际上，这相当于为NPC赋予了状态，通过AI的上下文机制来维持这种状态。</li>
<li>基于玩家行为的剧情分支：利用AI分析玩家在游戏中的所作所为，实时调整剧情走向。比如，玩家如果一直扮演一个行侠仗义的角色，AI可以在后续剧情中引入更多需要英雄主义的桥段，甚至生成一个专属的正义结局。反之，如果玩家选择了很多邪恶选项，AI可以让游戏走向“黑暗面”的分支。这种机制类似传统RPG的道德值系统，但借助AI可以更灵活地生成剧情细节，而不是依靠开发者手工撰写所有可能情节。</li>
<li>AI担任游戏主持（Dungeon Master）：大胆设想一下，让AI充当整个游戏的即时叙事者，根据玩家的一举一动来描述和推进故事。有点类似风靡一时的文本冒险游戏AI Dungeon。玩家每走到一个新场景，AI就绘声绘色地描述环境细节；玩家做出出乎意料的行为，AI即时决定世界的反应。这种玩法几乎能带来无剧本的开放世界体验。当然，实现这个目标需要精心设计提示词和约束，让AI的发挥既天马行空又不至于偏离游戏的基本规则，但一旦实现，将使游戏的自由度达到一个全新的高度。</li>
</ul>
<p>以上创意并非易事，但它们展示了AI在游戏开发领域的巨大潜力。开发者可以从小处着手，逐步将这些想法融入自己的项目中。随着对OpenAI API使用的日趋熟练，你完全可以尝试让AI承担更多游戏内容创作的重任，打造前所未有的RPG体验。</p>
<h2>结论</h2>
<p>将RPG Maker与OpenAI API相结合，为游戏开发开辟了一个全新的天地。通过生成式AI，我们的游戏不再是冰冷固定的程序，而是变得仿佛有了“生命”——剧情会呼吸，角色会思考，体验因玩家而异。本文中，我们探讨了整合AI带来的诸多优势，并手把手构建了一个动态对话的原型示例，可以看到哪怕只是加入一个简单的AI对话，游戏的趣味性也有了显著提升。</p>
<p>对于开发者来说，这样的尝试具有非常高的回报：投入一些时间学习并集成API，就可能让你的作品脱颖而出，给予玩家前所未有的新鲜体验。当然，过程中也会遇到一些挑战，例如API调用的延迟和费用、AI回复的不可控性等。这需要我们在实现时做好权衡，例如优化提示减少无用消耗、对AI输出进行适当约束，以及谨慎地保存好API密钥、防止滥用。</p>
<p>总体而言，AI技术正飞速发展，游戏开发者完全可以乘上这股东风，将AI作为强有力的工具来丰富自己的创作。也许在不久的将来，“会使用AI的游戏开发者”将成为行业标配。希望这篇分享能为你提供一些思路，无论是一个会聊天的NPC，还是一段随机生成的冒险剧情，都值得你去大胆尝试。放飞你的想象力，让AI与你一起打造独一无二的RPG游戏世界吧！</p>

    </article>
    </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
<script>
Prism.highlightAll();
document.querySelectorAll('article pre').forEach(pre => {
    const code = pre.querySelector('code');
    if (!code) return;
    const toolbar = document.createElement('div');
    toolbar.className = 'code-toolbar';
    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = () => {
        navigator.clipboard.writeText(code.textContent).then(() => {
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000);
        });
    };
    toolbar.appendChild(btn);
    pre.parentNode.insertBefore(toolbar, pre);
});
</script>
</body>
</html>