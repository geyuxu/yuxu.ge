<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的AI编程伙伴差点让项目翻车：一个惨痛的教训 | Yuxu Ge</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --black: #111;
            --dark-grey: #444;
            --off-white: #f4f4f4;
            --vermilion: #C41E3A;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--black);
            background-color: var(--off-white);
        }

        a { color: var(--vermilion); text-decoration: none; }
        a:hover { opacity: 0.75; }

        .layout { min-height: 100vh; }

        /* Sidebar */
        .sidebar {
            position: fixed; top: 0; left: 0;
            width: 320px; height: 100vh;
            background: var(--black); color: var(--off-white);
            padding: 3rem 2rem;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .sidebar-top { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .avatar { display: block; width: 120px; height: 120px; border-radius: 50%; border: 3px solid var(--vermilion); margin-bottom: 1.5rem; overflow: hidden; transition: transform 0.2s ease; }
        .avatar:hover { opacity: 1; transform: scale(1.05); }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .name-block { margin-bottom: 0.5rem; }
        h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: 1px; color: var(--off-white); }
        .title-role { font-size: 0.9rem; color: #888; margin-top: 0.25rem; font-weight: 400; }
        .contact-block { margin-top: 2.5rem; width: 100%; }
        .social-links { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .social-links a { display: flex; align-items: center; gap: 0.75rem; width: 160px; color: var(--off-white); opacity: 0.7; padding: 0.5rem 0.75rem; border-radius: 4px; font-size: 0.9rem; transition: all 0.2s; }
        .social-links a:hover { color: var(--vermilion); opacity: 1; background: rgba(255,255,255,0.05); }
        .social-links svg { width: 20px; height: 20px; flex-shrink: 0; }
        .social-links .orcid-link { font-size: 0.68rem; gap: 0.5rem; white-space: nowrap; }
        .sidebar-footer { text-align: center; font-size: 0.75rem; color: #555; }

        /* Content */
        .content { margin-left: 320px; padding: 3rem 4rem; max-width: 900px; }
        .back-link { display: inline-block; font-size: 0.85rem; margin-bottom: 2rem; color: var(--dark-grey); }
        .back-link:hover { color: var(--vermilion); }

        /* Article */
        article h1 { font-size: 2rem; font-weight: 700; margin-bottom: 1.5rem; line-height: 1.3; color: var(--black); }
        article h2 { font-size: 1.4rem; font-weight: 600; margin: 2rem 0 1rem; color: var(--black); }
        article h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; color: var(--black); }
        article p { margin-bottom: 1rem; color: var(--dark-grey); }
        article ul, article ol { margin: 1rem 0 1rem 1.5rem; color: var(--dark-grey); }
        article li { margin-bottom: 0.5rem; }
        article strong { color: var(--black); }
        article code { font-family: "SF Mono", Monaco, monospace; font-size: 0.9em; background: #e8e8e8; padding: 0.15em 0.4em; border-radius: 3px; }
        article pre { margin: 1rem 0; border-radius: 6px; overflow-x: auto; background: #2d2d2d; padding: 1rem; }
        article pre code { background: none; padding: 0; font-size: 0.75em; white-space: pre !important; counter-reset: line; display: block; color: #ccc; }
        article pre code .line { counter-increment: line; }
        article pre code .line::before { content: counter(line); display: inline-block; width: 2.5em; margin-right: 1em; text-align: right; color: #666; user-select: none; }
        .code-toolbar { display: flex; justify-content: flex-start; padding: 0.35rem 0.5rem; background: #3a3a3a; border-radius: 6px 6px 0 0; }
        .code-toolbar + pre { margin-top: 0; border-radius: 0 0 6px 6px; }
        .copy-btn { padding: 0.2rem 0.5rem; font-size: 0.7rem; background: #555; color: #fff; border: none; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
        .copy-btn:hover, .copy-btn:active { background: #777; }
        .copy-btn.copied { background: #2a2; }
        article blockquote { border-left: 3px solid var(--vermilion); padding-left: 1rem; margin: 1rem 0; color: #666; font-style: italic; }
        article hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        article table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        article th, article td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
        article th { background: #e8e8e8; font-weight: 600; }
        article img { max-width: 100%; height: auto; display: block; margin: 1.5rem 0; border-radius: 6px; }

        .loading { text-align: center; padding: 3rem; color: #888; }
        .error { color: var(--vermilion); }

        /* KaTeX math styles */
        .katex-display { overflow-x: auto; overflow-y: hidden; padding: 0.5rem 0; }
        .katex { font-size: 1.1em; }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { position: relative; width: 100%; height: auto; padding: 2rem 1.5rem 1rem; }
            .social-links { flex-direction: row; flex-wrap: wrap; justify-content: center; }
            .social-links a, .social-links .orcid-link { width: auto; padding: 0.5rem; font-size: 0; gap: 0; }
            .social-links svg { width: 24px; height: 24px; }
            .social-links .hide-mobile { display: none; }
            .sidebar-footer { margin-top: 1rem; }
            .content { margin-left: 0; padding: 2rem 1rem; }
        }
        @media (max-width: 480px) {
            .sidebar { padding: 1.5rem 1rem 1rem; }
            .avatar { width: 80px; height: 80px; }
            h1 { font-size: 1.4rem; }
            article h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="layout">
    <aside class="sidebar" id="sidebar-content"></aside>
    <script src="/components/sidebar.js"></script>

    <main class="content">
        <a href="/blog/" class="back-link">← Back to Blog</a>
        <article>
<hr>
<h2>date: 2025-07-27
tags: [ai, ai, 软件开发, 架构设计, 最佳实践, asyncio, python]
legacy: true</h2>
<h1>我的AI编程伙伴差点让项目翻车：一个惨痛的教训</h1>
<ol>
<li><strong>核心调度引擎</strong>：一个健壮的、基于<code>asyncio</code>的调度器。</li>
<li><strong>智能任务执行</strong>：一个能够分析任务结果并动态调整未来运行参数的系统。</li>
<li><strong>自我改进任务生成</strong>：AI可以根据性能指标或失败重写任务底层脚本的功能。</li>
<li><strong>人工票务系统</strong>：当任务不可恢复地失败时，系统会生成一个&quot;工单&quot;，人类可以审查、注释解决方案并反馈到系统的知识库中。</li>
</ol>
<p>AI勤奋地产出代码。票务系统被构建，自我改进钩子被添加，调度器被连接起来。表面上看，这像是一个巨大的成功。问题在于我在充当项目经理，而不是架构师。我在指定<em>构建什么</em>，但我没有严格指导<em>如何</em>构建和集成。</p>
<h2>与现实的碰撞：AI末日四骑士</h2>
<p>快速、未经审查的开发周期掩盖了深层次的问题。当我最终试图运行集成系统时，它崩溃了。根本原因并不新颖或奇特；它们是经典的软件工程失败，被AI放大和加速了。</p>
<h3>1. 过度工程的诱惑之歌</h3>
<p>AI没有业务上下文或架构前瞻性来说&quot;这一次太多了&quot;。它是一个极其强大的实现引擎。通过一次性要求所有功能，我无意中指导它为一个还不存在的未来构建解决方案，忽略了对稳定基础的直接需求。&quot;智能&quot;功能被强行附加到一个从未经过压力测试的核心上，创造了一个寻找问题的解决方案。</p>
<h3>2. 技术债务雪崩</h3>
<p>这就是理论问题变得痛苦具体的地方。AI在努力满足所有请求时，做出了创造根本冲突的权宜之计。</p>
<p>最明显的问题是<code>asyncio</code>事件循环冲突。不同的模块，可能在不同的AI提示中开发，试图独立管理事件循环。例如，核心调度器可能是这样初始化的：</p>
<p><strong>问题代码片段1：冲突的事件循环</strong></p>
<pre><code class="language-python"><span class="line"># 在scheduler_core.py中，由一个提示生成</span>
<span class="line">import asyncio</span>
<span class="line">from apscheduler.schedulers.asyncio import AsyncIOScheduler</span>
<span class="line"></span>
<span class="line">class MainScheduler:</span>
<span class="line">    def __init__(self):</span>
<span class="line">        self.scheduler = AsyncIOScheduler()</span>
<span class="line"></span>
<span class="line">    def run(self):</span>
<span class="line">        self.scheduler.start()</span>
<span class="line">        # 这个调用会永远阻塞，运行循环</span>
<span class="line">        asyncio.get_event_loop().run_forever() </span>
<span class="line"></span>
<span class="line"># 在ticketing_system.py中，由另一个提示生成</span>
<span class="line">import asyncio</span>
<span class="line"></span>
<span class="line">class TicketingSystem:</span>
<span class="line">    async def process_ticket(self, ticket_data):</span>
<span class="line">        # ... 逻辑 ...</span>
<span class="line">        print(&quot;处理工单&quot;)</span>
<span class="line"></span>
<span class="line">    def handle_failed_task(self, task_info):</span>
<span class="line">        # 这是反模式！它试图运行一个新循环</span>
<span class="line">        asyncio.run(self.process_ticket(task_info))</span></code></pre>
<p>当运行中的调度器调用<code>handle_failed_task</code>时，它会崩溃并显示<code>RuntimeError: This event loop is already running</code>。AI专注于票务系统的本地上下文，使用了方便的<code>asyncio.run()</code>，不知道它是更大的、已经运行的事件循环的一部分。</p>
<p>此外，选择<code>apscheduler</code>的<code>CronTrigger</code>引入了另一层复杂性。它的阻塞性质和独立的线程模型与我设想的完全异步设计不能很好地融合，导致时序错误和难以调试的竞态条件。</p>
<h3>3. 机器中的幽灵：无监督开发的危险</h3>
<p>我的开发过程是有缺陷的。我把AI当作自主开发者，给它一个功能列表并期望一个连贯的结果。我放弃了作为架构师和审查者的角色。</p>
<p>如果要求人类开发者构建所有这些，他们会反击。他们会要求澄清，提出分阶段推出，并对复杂性提出担忧。AI没有。它只是执行，编织一个纠结的网，没有来自经验的整体理解。没有每一步的定期手动代码审查和集成测试，我对不断积累的架构腐败是盲目的。</p>
<h3>4. 架构纠缠</h3>
<p>最终结果是一个紧密耦合的单体。&quot;自动改进任务生成&quot;模块对<code>TicketingSystem</code>的内部数据结构有直接依赖。<code>MainScheduler</code>知道&quot;智能任务执行&quot;模块工作方式的内部细节。</p>
<p><strong>概念问题：紧密耦合</strong></p>
<pre><code class="language-python"><span class="line"># 之前：依赖关系的混乱</span>
<span class="line">class MainScheduler:</span>
<span class="line">    def __init__(self):</span>
<span class="line">        # 调度器直接实例化其&quot;智能&quot;组件</span>
<span class="line">        self.improver = AutoTaskImprover()</span>
<span class="line">        self.ticketer = TicketingSystem()</span>
<span class="line"></span>
<span class="line">    def _execute_task(self, task):</span>
<span class="line">        result = task.run()</span>
<span class="line">        if not result.success:</span>
<span class="line">            # 直接调用另一个模块的实现</span>
<span class="line">            new_script = self.improver.analyze_and_suggest_fix(task.script, result.error)</span>
<span class="line">            if new_script:</span>
<span class="line">                task.update_script(new_script)</span>
<span class="line">            else:</span>
<span class="line">                # 另一个直接的深度调用</span>
<span class="line">                self.ticketer.handle_failed_task(task.info) </span></code></pre>
<p>调试是一场噩梦。一个组件的失败会在整个系统中级联，使得无法隔离根本原因。系统不是一个协作模块的集合；它是一台单一的、脆弱的机器。</p>
<h2>恢复：人机合作的经验教训</h2>
<p>从这个边缘爬回来是一次谦逊的练习，也是回归第一原则。恢复过程给了我一个与AI合作的清晰框架，既能利用其力量又不会屈服于其陷阱。</p>
<h3>经验教训1：拥抱渐进主义（&quot;爬行、行走、奔跑&quot;方法）</h3>
<p>第一步是把它全部拆掉。我重新开始，有一个明确的目标：构建一个坚如磐石的、简单的、异步任务调度器。没有&quot;智能&quot;，没有&quot;自我改进&quot;。只是一个稳定的核心。</p>
<p>只有在这个核心被构建、测试和验证之后，我才开始逐一添加AI功能。每个新功能都被开发为一个独特的、可选的模块，而不是核心组件。</p>
<p><strong>修复：模块化、可插拔架构</strong></p>
<pre><code class="language-python"><span class="line"># 之后：使用依赖注入的清洁、解耦设计</span>
<span class="line"></span>
<span class="line"># --- 核心调度器（对&quot;智能&quot;功能一无所知）---</span>
<span class="line">class MainScheduler:</span>
<span class="line">    def __init__(self, plugins=None):</span>
<span class="line">        self.plugins = plugins or []</span>
<span class="line"></span>
<span class="line">    def _execute_task(self, task):</span>
<span class="line">        result = task.run()</span>
<span class="line">        if not result.success:</span>
<span class="line">            # 核心只发布事件，它不知道消费者</span>
<span class="line">            self.publish_event(&#39;task_failed&#39;, task=task, result=result)</span>
<span class="line"></span>
<span class="line">    def publish_event(self, event_type, **kwargs):</span>
<span class="line">        for plugin in self.plugins:</span>
<span class="line">            if hasattr(plugin, f&quot;on_{event_type}&quot;):</span>
<span class="line">                getattr(plugin, f&quot;on_{event_type}&quot;)(**kwargs)</span>
<span class="line"></span>
<span class="line"># --- 可选插件 ---</span>
<span class="line">class AutoImprovementPlugin:</span>
<span class="line">    def on_task_failed(self, task, result):</span>
<span class="line">        # 改进任务的逻辑现在被隔离在这里</span>
<span class="line">        print(f&quot;插件：分析任务失败 {task.id}&quot;)</span>
<span class="line">        # ...</span>
<span class="line"></span>
<span class="line"># --- 主应用程序连接 ---</span>
<span class="line">core_scheduler = MainScheduler(plugins=[AutoImprovementPlugin()])</span>
<span class="line"># 现在智能功能是可选插件，而不是核心依赖</span></code></pre>
<p>这种方法保持核心清洁，并允许功能被启用、禁用或替换，而不影响系统的其余部分。</p>
<h3>经验教训2：人在回路中是不可协商的</h3>
<p>我把角色从&quot;项目经理&quot;改为&quot;首席架构师和高级开发者&quot;。AI是我聪明但缺乏经验的初级伙伴。我的新工作流程如下：</p>
<ol>
<li><strong>定义一个小的、隔离的任务</strong>（例如，&quot;创建一个插件类，将任务失败记录到JSON文件&quot;）</li>
<li><strong>AI生成代码</strong></li>
<li><strong>我批判性地审查每一行</strong>。我检查反模式、架构不匹配和错误假设。</li>
<li><strong>我自己重构和集成代码</strong>。我是将其连接到主应用程序的人，确保它遵循既定的架构。</li>
<li><strong>我编写集成测试并提交</strong></li>
</ol>
<p>这个以人为中心的循环是我做出的最重要的改变。它让我控制架构和质量。</p>
<h3>经验教训3：简单（仍然）胜过复杂</h3>
<p><code>asyncio</code>问题通过执行一个简单的规则得到解决：只有一个事件循环，它由应用程序的入口点管理。模块和插件绝不能调用<code>asyncio.run()</code>或<code>loop.run_forever()</code>。相反，它们暴露主循环可以<code>await</code>的<code>async</code>函数。</p>
<p><strong>修复：单一、统一的事件循环</strong></p>
<pre><code class="language-python"><span class="line"># 在插件文件中（例如，ticketing_plugin.py）</span>
<span class="line">class TicketingPlugin:</span>
<span class="line">    async def on_task_failed(self, task, result):</span>
<span class="line">        # 这个函数现在是异步的，期望被await</span>
<span class="line">        await self.create_ticket(task.info)</span>
<span class="line"></span>
<span class="line">    async def create_ticket(self, info):</span>
<span class="line">        print(f&quot;为 {info} 创建工单&quot;)</span>
<span class="line">        # ... await 异步I/O操作 ...</span>
<span class="line">        await asyncio.sleep(0.1) </span>
<span class="line"></span>
<span class="line"># 在主应用程序入口点</span>
<span class="line">async def main():</span>
<span class="line">    # 插件现在设计为被await</span>
<span class="line">    ticketing_plugin = TicketingPlugin()</span>
<span class="line">    scheduler = MainScheduler(plugins=[ticketing_plugin])</span>
<span class="line">    </span>
<span class="line">    # 调度器的`publish_event`需要是异步的</span>
<span class="line">    # 并await插件调用</span>
<span class="line">    </span>
<span class="line">    # ... 启动逻辑 ...</span>
<span class="line">    await scheduler.run() # 主run函数现在是可等待的</span>
<span class="line"></span>
<span class="line">if __name__ == &quot;__main__&quot;:</span>
<span class="line">    # 运行事件循环的唯一地方</span>
<span class="line">    asyncio.run(main())</span></code></pre>
<p>这个架构原则——简单性——必须由人类开发者执行。AI为本地目标优化，可能不会选择最简单的全局路径。</p>
<h2>最后的思考：飞行员，而不是乘客</h2>
<p>AI开发工具不是你项目的自主驾驶员；它们是极其强大的副驾驶。它们可以处理复杂的机动、处理大量信息，并以超人的速度执行指令。但人类开发者必须保持机长的身份，负责飞行计划（架构）、起飞前检查（代码审查）和旅程的最终方向。</p>
<p>我在Nighthawks的经历教会了我AI的承诺是真实的，但它需要一种新的纪律。我们必须抵制让它无监督运行的诱惑。相反，我们必须指导它、质疑它，并将其输出与只有人类架构师才能提供的智慧和远见相结合。</p>
<p>通过将我们的战略监督与AI的战术能力配对，我们可以避免飞入复杂性的风暴，而是导航建造真正出色的软件。</p>
<h2>关键要点</h2>
<ol>
<li><strong>从简单开始</strong>：在添加智能功能之前构建坚实的基础</li>
<li><strong>人工审查至关重要</strong>：每个AI生成的代码都需要人工架构审查</li>
<li><strong>模块化设计</strong>：保持功能可选和松散耦合</li>
<li><strong>增量开发</strong>：一次添加一个功能并彻底测试</li>
<li><strong>架构很重要</strong>：人类必须保持架构师的身份，而不仅仅是项目经理</li>
</ol>
<p>软件开发的未来不在于用AI替代人类判断，而在于创建一个伙伴关系，其中每个人都贡献他们独特的优势，更快、更可靠地构建更好的软件。</p>

    </article>
    </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
<script>
Prism.highlightAll();
document.querySelectorAll('article pre').forEach(pre => {
    const code = pre.querySelector('code');
    if (!code) return;
    const toolbar = document.createElement('div');
    toolbar.className = 'code-toolbar';
    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = () => {
        navigator.clipboard.writeText(code.textContent).then(() => {
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000);
        });
    };
    toolbar.appendChild(btn);
    pre.parentNode.insertBefore(toolbar, pre);
});
</script>
</body>
</html>