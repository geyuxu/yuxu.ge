<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pandas Basics: Core Objects & Common Operations | Yuxu Ge</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --black: #111;
            --dark-grey: #444;
            --off-white: #f4f4f4;
            --vermilion: #C41E3A;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--black);
            background-color: var(--off-white);
        }

        a { color: var(--vermilion); text-decoration: none; }
        a:hover { opacity: 0.75; }

        .layout { min-height: 100vh; }

        /* Sidebar */
        .sidebar {
            position: fixed; top: 0; left: 0;
            width: 320px; height: 100vh;
            background: var(--black); color: var(--off-white);
            padding: 3rem 2rem;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .sidebar-top { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .avatar { display: block; width: 120px; height: 120px; border-radius: 50%; border: 3px solid var(--vermilion); margin-bottom: 1.5rem; overflow: hidden; transition: transform 0.2s ease; }
        .avatar:hover { opacity: 1; transform: scale(1.05); }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .name-block { margin-bottom: 0.5rem; }
        h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: 1px; color: var(--off-white); }
        .title-role { font-size: 0.9rem; color: #888; margin-top: 0.25rem; font-weight: 400; }
        .contact-block { margin-top: 2.5rem; width: 100%; }
        .social-links { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .social-links a { display: flex; align-items: center; gap: 0.75rem; width: 160px; color: var(--off-white); opacity: 0.7; padding: 0.5rem 0.75rem; border-radius: 4px; font-size: 0.9rem; transition: all 0.2s; }
        .social-links a:hover { color: var(--vermilion); opacity: 1; background: rgba(255,255,255,0.05); }
        .social-links svg { width: 20px; height: 20px; flex-shrink: 0; }
        .social-links .orcid-link { font-size: 0.68rem; gap: 0.5rem; white-space: nowrap; }
        .sidebar-footer { text-align: center; font-size: 0.75rem; color: #555; }

        /* Content */
        .content { margin-left: 320px; padding: 3rem 4rem; max-width: 900px; }
        .back-link { display: inline-block; font-size: 0.85rem; margin-bottom: 2rem; color: var(--dark-grey); }
        .back-link:hover { color: var(--vermilion); }

        /* Article */
        article h1 { font-size: 2rem; font-weight: 700; margin-bottom: 1.5rem; line-height: 1.3; color: var(--black); }
        article h2 { font-size: 1.4rem; font-weight: 600; margin: 2rem 0 1rem; color: var(--black); }
        article h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; color: var(--black); }
        article p { margin-bottom: 1rem; color: var(--dark-grey); }
        article ul, article ol { margin: 1rem 0 1rem 1.5rem; color: var(--dark-grey); }
        article li { margin-bottom: 0.5rem; }
        article strong { color: var(--black); }
        article code { font-family: "SF Mono", Monaco, monospace; font-size: 0.9em; background: #e8e8e8; padding: 0.15em 0.4em; border-radius: 3px; }
        article pre { margin: 1rem 0; border-radius: 6px; overflow-x: auto; background: #2d2d2d; padding: 1rem; }
        article pre code { background: none; padding: 0; font-size: 0.75em; white-space: pre !important; counter-reset: line; display: block; color: #ccc; }
        article pre code .line { counter-increment: line; }
        article pre code .line::before { content: counter(line); display: inline-block; width: 2.5em; margin-right: 1em; text-align: right; color: #666; user-select: none; }
        .code-toolbar { display: flex; justify-content: flex-start; padding: 0.35rem 0.5rem; background: #3a3a3a; border-radius: 6px 6px 0 0; }
        .code-toolbar + pre { margin-top: 0; border-radius: 0 0 6px 6px; }
        .copy-btn { padding: 0.2rem 0.5rem; font-size: 0.7rem; background: #555; color: #fff; border: none; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
        .copy-btn:hover, .copy-btn:active { background: #777; }
        .copy-btn.copied { background: #2a2; }
        article blockquote { border-left: 3px solid var(--vermilion); padding-left: 1rem; margin: 1rem 0; color: #666; font-style: italic; }
        article hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        article table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        article th, article td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
        article th { background: #e8e8e8; font-weight: 600; }
        article img { max-width: 100%; height: auto; display: block; margin: 1.5rem 0; border-radius: 6px; }

        .loading { text-align: center; padding: 3rem; color: #888; }
        .error { color: var(--vermilion); }

        /* KaTeX math styles */
        .katex-display { overflow-x: auto; overflow-y: hidden; padding: 0.5rem 0; }
        .katex { font-size: 1.1em; }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { position: relative; width: 100%; height: auto; padding: 2rem 1.5rem 1rem; }
            .social-links { flex-direction: row; flex-wrap: wrap; justify-content: center; }
            .social-links a, .social-links .orcid-link { width: auto; padding: 0.5rem; font-size: 0; gap: 0; }
            .social-links svg { width: 24px; height: 24px; }
            .social-links .hide-mobile { display: none; }
            .sidebar-footer { margin-top: 1rem; }
            .content { margin-left: 0; padding: 2rem 1rem; }
        }
        @media (max-width: 480px) {
            .sidebar { padding: 1.5rem 1rem 1rem; }
            .avatar { width: 80px; height: 80px; }
            h1 { font-size: 1.4rem; }
            article h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="layout">
    <aside class="sidebar" id="sidebar-content"></aside>
    <script src="/components/sidebar.js"></script>

    <main class="content">
        <a href="/blog/" class="back-link">← Back to Blog</a>
        <article>
<hr>
<h2>date: 2023-04-23
tags: [pandas, data-analysis, python]
legacy: true</h2>
<h1>Pandas Basics: Core Objects &amp; Common Operations</h1>
<pre><code class="language-python"><span class="line">import pandas as pd</span>
<span class="line">import numpy as np</span>
<span class="line"></span>
<span class="line"># 创建一个最简单的 Series：不指定索引时，会自动使用0,1,2,...作为索引</span>
<span class="line">s1 = pd.Series([10, 20, 30, 40])</span>
<span class="line">print(s1)</span>
<span class="line"># 输出:</span>
<span class="line"># 0    10</span>
<span class="line"># 1    20</span>
<span class="line"># 2    30</span>
<span class="line"># 3    40</span>
<span class="line"># dtype: int64</span>
<span class="line"></span>
<span class="line"># 创建 Series 时指定索引</span>
<span class="line">s2 = pd.Series([100, 98, 67, 23], index=[&#39;zs&#39;, &#39;ls&#39;, &#39;ww&#39;, &#39;sl&#39;])</span>
<span class="line">print(s2)</span>
<span class="line"># 输出:</span>
<span class="line"># zs    100</span>
<span class="line"># ls     98</span>
<span class="line"># ww     67</span>
<span class="line"># sl     23</span>
<span class="line"># dtype: int64</span>
<span class="line"># 这是一个 Series：左边是索引(index)，右边是对应的值，dtype 表示值的数据类型</span>
<span class="line"></span>
<span class="line"># 通过字典创建 Series，键会成为索引，值成为数据</span>
<span class="line">d = {&#39;zs&#39;: 100, &#39;ls&#39;: 98, &#39;ww&#39;: 67, &#39;sl&#39;: 23}</span>
<span class="line">s3 = pd.Series(d)</span>
<span class="line">print(s3)</span>
<span class="line"># 输出与上面 s2 相同（字典键的插入顺序即索引顺序）</span></code></pre>
<p>上面代码展示了三种创建 Series 的方式：直接由列表创建（可以指定索引，也可以不指定用默认索引0,1,2,…），以及由字典创建。一般来说，通过列表创建可以灵活指定索引顺序，而通过字典创建会使用字典的键作为索引（顺序为插入顺序）。两者效果类似，都得到一个带索引的一维数据序列。</p>
<p>还有一种快捷方式，如果想要创建内容全部相同的 Series，可以直接传入一个常数值和索引。例如下面代码将生成10个元素都为0.2的Series：</p>
<pre><code class="language-python"><span class="line"># 创建一个包含10个0.2的 Series</span>
<span class="line">s4 = pd.Series(0.2, index=range(10))</span>
<span class="line">print(s4.head(3))  # 先看头3行</span>
<span class="line"># 输出:</span>
<span class="line"># 0    0.2</span>
<span class="line"># 1    0.2</span>
<span class="line"># 2    0.2</span>
<span class="line"># dtype: float64</span></code></pre>
<p>可以看到，s4的每个元素都是0.2，指数0到9。head(3)方法返回前3行，便于我们预览数据。</p>
<h3>Series 的数据访问</h3>
<p>Series 有点类似于 Python 的列表和字典的结合，在访问数据时既可以用位置下标也可以用标签索引。需要注意的是：Series同时支持基于位置和基于标签的索引方式，这两套索引彼此独立。</p>
<ul>
<li>位置索引（下标）：按照元素的位置顺序，从0开始计数。例如 s[0] 取第一个元素，s[1:3] 取切片。</li>
<li>标签索引（index）：按照我们定义的索引值来取。例如索引是字符串 ‘zs’，用 s[&#39;zs&#39;] 来取对应的值。</li>
</ul>
<p>下面用具体例子说明 Series 的两种索引方法：</p>
<pre><code class="language-python"><span class="line">s = pd.Series([100, 78, 98, 79], index=[&#39;zs&#39;, &#39;ls&#39;, &#39;ww&#39;, &#39;sl&#39;])</span>
<span class="line"># 这个 Series 的索引为 &#39;zs&#39;,&#39;ls&#39;,&#39;ww&#39;,&#39;sl&#39;，对应的值如列表所给</span>
<span class="line"></span>
<span class="line"># 按位置索引访问</span>
<span class="line">print(s[3])      # 第4个元素，位置从0开始计数</span>
<span class="line">print(s[:2])     # 前2个元素的切片（不包含位置2）</span>
<span class="line">print(s[[0, 2]]) # 位置0和2的元素，返回一个新的 Series</span>
<span class="line"></span>
<span class="line"># 按标签索引访问</span>
<span class="line">print(s[&#39;sl&#39;])              # 索引标签为 &#39;sl&#39; 的元素</span>
<span class="line">print(s[&#39;zs&#39;:&#39;ww&#39;])         # 按标签切片，包含 &#39;zs&#39; 到 &#39;ww&#39;（注意包含末端）</span>
<span class="line">print(s[[&#39;zs&#39;, &#39;ww&#39;, &#39;sl&#39;]])# 指定标签列表，返回多个元素</span></code></pre>
<p>上述代码中，s[3] 通过位置获取到了第4个元素 79，而 s[&#39;sl&#39;] 则通过标签获取到了对应的值 79。区别：切片时，s[:2]按位置取不包括索引2，而 s[&#39;zs&#39;:&#39;ww&#39;]按标签取则是包含 &#39;ww&#39; 这个索引的（也就是包含切片区间的末端）。这点与 Python 基本切片规则不同，需要特别注意。</p>
<p>另外，Series 不支持像 Python 列表那样的负索引。也就是说，s[-1] 并不能取最后一个元素（除非你的索引恰好有 -1 这个标签）。如果需要取最后一个元素，可以使用 s.iloc[-1]（iloc 是后面会介绍的按位置选取的通用方式）。总之，Series 的下标索引只有正向的，没有反向的。</p>
<p>我们还可以查看 Series 的一些属性来了解数据结构：</p>
<pre><code class="language-python"><span class="line">print(s.index)   # Index([&#39;zs&#39;, &#39;ls&#39;, &#39;ww&#39;, &#39;sl&#39;], dtype=&#39;object&#39;)</span>
<span class="line">print(s.values)  # [100  78  98  79]，值本身是一个 numpy.ndarray</span>
<span class="line">print(s.dtype)   # int64，值的数据类型</span>
<span class="line">print(s.shape)   # (4,)，Series 的形状，相当于长度为4的一维数组</span>
<span class="line">print(s.size)    # 4，元素个数</span>
<span class="line">print(s.ndim)    # 1，维度，对于Series永远是1</span></code></pre>
<p>index 属性返回一个 Index 对象，包含 Series 的索引列表；values 则返回一个包含所有值的 NumPy 数组。在这个例子中，值全是整数，所以 dtype 是 int64。如果数据包含浮点或出现 NaN（缺失值），dtype 可能变为 float64。shape、size、ndim 等属性和 NumPy 的数组类似，分别表示数据的形状、元素数量和维度。</p>
<h2>DataFrame 是什么</h2>
<p>DataFrame 是 Pandas 中更为常用的二维表结构，可以理解为“带行标签和列标签的表格数据”。如果说 Series 有点像 Excel 中的一列，那么 DataFrame 就像整个表格（由多列组成），同时拥有行索引（index）和列名（columns）。DataFrame 也可以看作由多个共享同一个索引的 Series 组成的字典，每一列是一个 Series，列名是字典的键。</p>
<p>举个例子，一个 DataFrame 可以用来表示多个人的若干属性，例如姓名、年龄、性别，每一列是一种属性，每一行代表一个人。我们可以使用多种方式来构造 DataFrame，常见的方法包括：由字典、由列表组成的列表、由多个 Series 等。下面通过代码来演示 DataFrame 的创建和基本属性。</p>
<pre><code class="language-python"><span class="line">import pandas as pd</span>
<span class="line"></span>
<span class="line"># 通过字典创建 DataFrame，每个键代表一列</span>
<span class="line">data = {</span>
<span class="line">    &#39;Name&#39;: [&#39;Tom&#39;, &#39;Jerry&#39;, &#39;Jack&#39;, &#39;Rose&#39;],</span>
<span class="line">    &#39;Age&#39;: [18, 18, 20, 20]</span>
<span class="line">}</span>
<span class="line">df = pd.DataFrame(data)</span>
<span class="line">print(df)</span>
<span class="line"># 输出:</span>
<span class="line">#    Name  Age</span>
<span class="line"># 0   Tom   18</span>
<span class="line"># 1 Jerry   18</span>
<span class="line"># 2  Jack   20</span>
<span class="line"># 3  Rose   20</span></code></pre>
<p>上面用字典创建了一个简单的 DataFrame df，包含两列：Name 和 Age。因为我们没有指定索引，Pandas 自动用了默认的整数索引 0,1,2,3。可以看到 DataFrame 打印输出时，会显示行索引和列名，以及每个单元格的数据。</p>
<p>我们也可以指定自己的索引。例如，如果我们想用 a, b, c, d 作为每行的索引标签，可以传入参数 index= 来指定；另外用 columns= 可以指定列名的顺序。下面我们构造一个稍微复杂一点的 DataFrame：多加一列 Gender，并且让不同列来自不同长度的 Series，以演示 Pandas 会如何对齐数据。</p>
<pre><code class="language-python"><span class="line"># 用字典包含多个 Series 来创建 DataFrame，各 Series 按索引自动对齐</span>
<span class="line">data2 = {</span>
<span class="line">    &#39;Name&#39;: pd.Series([&#39;Tom&#39;, &#39;Jerry&#39;, &#39;Jack&#39;, &#39;Rose&#39;], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]),</span>
<span class="line">    &#39;Age&#39;: pd.Series([18, 18, 20], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),      # 少了索引 &#39;d&#39;</span>
<span class="line">    &#39;Gender&#39;: pd.Series([&#39;M&#39;, &#39;M&#39;, &#39;F&#39;], index=[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;]) # 少了索引 &#39;b&#39;</span>
<span class="line">}</span>
<span class="line">df2 = pd.DataFrame(data2)</span>
<span class="line">print(df2)</span>
<span class="line"># 输出:</span>
<span class="line">#   Name   Age Gender</span>
<span class="line"># a   Tom  18.0      M</span>
<span class="line"># b Jerry  18.0    NaN</span>
<span class="line"># c  Jack  20.0      F</span>
<span class="line"># d  Rose   NaN      M</span></code></pre>
<p>在这个 df2 DataFrame 中，我们指定了索引为 &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;。Name 列有这四个索引的值，但 Age 列缺少 &#39;d&#39;的值，Gender 列缺少 &#39;b&#39;的值。Pandas 会根据索引自动对齐不同列的数据：对于缺失的位置以 NaN 填充。上面输出中，索引 b 的 Gender 显示为 NaN（因为没有提供 b 对应的 Gender），索引 d 的 Age 为 NaN（没有提供 d 对应的 Age）。NaN 表示缺失值，在 Pandas 中是一种特殊的浮点型值。</p>
<blockquote>
<p><strong>注意</strong>： 由上述例子也可以看出，DataFrame 中每列数据可以是不同类型（Name 是字符串，Age 是数字，Gender 是字符串）。当某列出现 NaN 时，该列会被Upcast为浮点型，因为 NaN 被视作浮点类型特殊值。例如 Age 列本来是整数，一旦出现 NaN，就变成了 float。</p>
</blockquote>
<p>如果我们不想让某些值缺失，可以在创建 DataFrame 时提供完整的数据，对齐索引。或者创建后再手动填充缺失值。但这些属于后续处理范畴。</p>
<h3>DataFrame 的属性和基本操作</h3>
<p>类似于 Series，DataFrame 提供了许多属性和方法方便我们了解数据集的总体情况：</p>
<ul>
<li><code>df.index</code>：获取行索引(Index对象)。</li>
<li><code>df.columns</code>：获取列名(Index对象)。</li>
<li><code>df.values</code>：以二维 numpy 数组的形式获取表格中的值。</li>
<li><code>df.shape</code>：返回 (行数, 列数) 的元组。</li>
<li><code>df.dtypes</code>：获取每一列的数据类型。</li>
<li><code>df.size</code>：返回元素总数 (行数 × 列数)。</li>
<li><code>df.empty</code>：布尔值，表示 DataFrame 是否为空（没有任何数据）。</li>
<li><code>df.head(n)</code>：查看前 n 行数据（默认 n=5）。</li>
<li><code>df.tail(n)</code>：查看最后 n 行数据。</li>
<li><code>df.describe()</code>：对数值列进行统计汇总（计数、均值、标准差、最小值、四分位数等）。</li>
<li><code>df.T</code>：获取转置的 DataFrame（行列互换）。</li>
</ul>
<p>举例来说，我们可以查看 df2 的一些基本信息：</p>
<pre><code class="language-python"><span class="line">print(df2.index)    # Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)</span>
<span class="line">print(df2.columns)  # Index([&#39;Name&#39;, &#39;Age&#39;, &#39;Gender&#39;], dtype=&#39;object&#39;)</span>
<span class="line">print(df2.shape)    # (4, 3) -&gt; 4 行 3 列</span>
<span class="line">print(df2.dtypes)   </span>
<span class="line"># Name      object</span>
<span class="line"># Age      float64</span>
<span class="line"># Gender    object</span>
<span class="line"># dtype: object</span>
<span class="line"></span>
<span class="line">print(df2.head(2))</span>
<span class="line">#   Name   Age Gender</span>
<span class="line"># a   Tom  18.0      M</span>
<span class="line"># b Jerry  18.0    NaN</span>
<span class="line"></span>
<span class="line">print(df2.describe())</span>
<span class="line">#              Age</span>
<span class="line"># count   3.000000</span>
<span class="line"># mean   18.666667</span>
<span class="line"># std     1.154701</span>
<span class="line"># min    18.000000</span>
<span class="line"># 25%    18.000000</span>
<span class="line"># 50%    18.000000</span>
<span class="line"># 75%    19.000000</span>
<span class="line"># max    20.000000</span></code></pre>
<p>这里我们看到：index 和 columns 列出了 DataFrame 的索引和列标签，shape说明有4行3列。dtypes表明 Name 和 Gender 是object类型（字符串），Age是float64。head(2)输出了前两行数据，describe()则对 Age 列给出了统计摘要（因为 Name 和 Gender 非数字列被自动忽略）。</p>
<p>了解了 Series 和 DataFrame 的基本结构，下面我们进入更具体的增删改查操作，以 DataFrame 为中心进行讲解。在以下示例中，我们将继续使用刚才创建的 df2 来演示。</p>
<h2>列操作 CRUD</h2>
<p>通常我们需要对 DataFrame 的列进行各种操作，例如读取某几列数据、添加新列、修改已有列或者删除列。DataFrame 在列操作上非常类似于 Python 的字典：把 DataFrame 当做一个字典的话，键就是列名，值是一列数据（一个 Series）。因此许多列操作可以类比为字典操作来记忆。</p>
<p>下面我们按照查（读取）、增（添加）、改（修改）、删（删除）的顺序，演示列的常见操作。</p>
<p>查（读取列）： DataFrame 可以通过列名来获取列数据。最简单的方式是使用方括号 <code>df[&#39;列名&#39;]</code>，这会返回一个 Series，包含该列的所有数据和对应的行索引。另外，也可以传入一个列名列表 <code>df[[&#39;列名1&#39;,&#39;列名2&#39;]]</code> 来一次获取多列数据（此时返回一个新的 DataFrame）。需要注意的是，不能直接使用切片 <code>df[&#39;col1&#39;:&#39;col3&#39;]</code> 来选取多列，方括号中如果给的是切片会被解释为行切片（这是为了保持语义简单一致，方括号直接索引默认为列，切片符号默认为行切片，这点细节稍微有点反直觉）。</p>
<p>我们来看具体例子：</p>
<pre><code class="language-python"><span class="line">df = df2  # 继续使用前面的 df2: 有 Name, Age, Gender 三列，索引 a,b,c,d</span>
<span class="line"></span>
<span class="line"># 访问单列数据</span>
<span class="line">name_col = df[&#39;Name&#39;]</span>
<span class="line">print(name_col)           # 获取 Name 列（类型为 Series）</span>
<span class="line"></span>
<span class="line"># 访问多列数据</span>
<span class="line">subset = df[[&#39;Name&#39;, &#39;Age&#39;]]</span>
<span class="line">print(subset)             # 获取 Name 和 Age 两列，返回 DataFrame</span>
<span class="line"></span>
<span class="line"># 利用 df.columns 得到列名列表，比如去掉最后一列:</span>
<span class="line">print(df[df.columns[:-1]])# 获取除最后一列外的所有列</span></code></pre>
<p>输出（省略部分）将展示 name_col 是一个 Series，内容就是每个索引对应的 Name；而 subset 是一个 DataFrame，包含两列 Name 和 Age。最后一行通过 df.columns[:-1] 切片拿到了除最后一列（Gender）以外的列名列表，实现了获取多列的另一种方法。</p>
<p>值得一提的是，Pandas 允许通过属性访问的方式获取列，例如 df.Name 可以直接得到 Name 列，这跟 df[&#39;Name&#39;] 是等价的（前提是列名是合法的 Python 标识符且不与现有属性方法同名）。但是如果列名包含空格或特殊字符，或者碰巧和 DataFrame 的方法名冲突，就不能用点属性访问。建议初学者还是使用 df[...] 这种明确的方式。</p>
<blockquote>
<p><strong>注意</strong>： 如果列名中包含空格，比如 &quot;Total Sales&quot; 这种，不能用 df.Total Sales（会语法错误或解析错误），此时必须用 df[&#39;Total Sales&#39;] 来访问。同样地，列名包含点号、减号等特殊字符，或列名叫max、count等与DataFrame方法重名，也只能使用 df[&#39;列名&#39;] 的方式。如果想方便地用点访问，最好的办法是统一修改列名，例如用 <code>df.columns = df.columns.str.replace(&#39; &#39;, &#39;_&#39;)</code> 将空格替换为下划线，或者使用 df.rename 重命名列。</p>
</blockquote>
<p>增（添加列）： 向 DataFrame 增加新列也很直观：直接像字典赋值一样 <code>df[&#39;新列名&#39;] = ...</code> 即可。赋值的“…”可以是以下几种：</p>
<ul>
<li>一个固定值：则整列都会被这个值填充。</li>
<li>一个列表或 ndarray：长度需要跟 DataFrame 的行数相等，数据会按顺序填充这一列。</li>
<li>一个 Pandas 的 Series：如果 Series 的索引能对齐 DataFrame 的索引，那么会根据索引匹配填充，索引没有对应上的位置将出现 NaN。</li>
</ul>
<p>也可以一次性添加多列。Pandas 提供了 pd.concat 方法，可以用来把两个DataFrame按列方向拼接（axis=1）从而增加新列。此外，df.assign() 方法也可以同时添加多列，不过这里不展开。下面通过代码演示各种添加列的方式：</p>
<pre><code class="language-python"><span class="line"># 原始 DataFrame 回顾:</span>
<span class="line">print(df)</span>
<span class="line">#   Name   Age Gender</span>
<span class="line"># a   Tom  18.0      M</span>
<span class="line"># b Jerry  18.0    NaN</span>
<span class="line"># c  Jack  20.0      F</span>
<span class="line"># d  Rose   NaN      M</span>
<span class="line"></span>
<span class="line"># 1. 直接赋值列表，添加一列</span>
<span class="line">df[&#39;Math&#39;] = [100, 100, 100, 100]   # 所有行的 Math 值都是100</span>
<span class="line">print(df)</span>
<span class="line"># 新增了 Math 列:</span>
<span class="line">#   Name   Age Gender  Math</span>
<span class="line"># a   Tom  18.0      M   100</span>
<span class="line"># b Jerry  18.0    NaN   100</span>
<span class="line"># c  Jack  20.0      F   100</span>
<span class="line"># d  Rose   NaN      M   100</span>
<span class="line"></span>
<span class="line"># 2. 赋值一个 Series，按索引对齐添加新列</span>
<span class="line">df[&#39;English&#39;] = pd.Series([95, 96, 97], index=[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])</span>
<span class="line">print(df)</span>
<span class="line"># 新增 English 列（对齐索引，有缺失）:</span>
<span class="line">#   Name   Age Gender  Math  English</span>
<span class="line"># a   Tom  18.0      M   100     95.0</span>
<span class="line"># b Jerry  18.0    NaN   100     96.0</span>
<span class="line"># c  Jack  20.0      F   100      NaN  # c 没有 English 值，NaN</span>
<span class="line"># d  Rose   NaN      M   100     97.0</span>
<span class="line"></span>
<span class="line"># 3. 用 concat 横向拼接添加多列</span>
<span class="line">new_cols = pd.DataFrame({</span>
<span class="line">    &#39;Chinese&#39;: [50, 50, 50, 50],</span>
<span class="line">    &#39;P.E.&#39;: [60, 60, 60, 60]</span>
<span class="line">}, index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="line">df = pd.concat([df, new_cols], axis=1)</span>
<span class="line">print(df)</span>
<span class="line"># 新增了 Chinese 和 P.E. 两列:</span>
<span class="line">#   Name   Age Gender  Math  English  Chinese  P.E.</span>
<span class="line"># a   Tom  18.0      M   100     95.0      50    60</span>
<span class="line"># b Jerry  18.0    NaN   100     96.0      50    60</span>
<span class="line"># c  Jack  20.0      F   100      NaN      50    60</span>
<span class="line"># d  Rose   NaN      M   100     97.0      50    60</span></code></pre>
<p>上面的操作依次给 DataFrame 添加了 Math 列（所有值相同），English 列（只有索引 a,b,d 有值，c 自动补NaN），以及通过 pd.concat 一次拼接两个新列 Chinese 和 P.E.。需要留意的是，我们使用了 &#39;P.E.&#39; 作为列名，这里包含了一个点号，今后访问 P.E. 列就不能用 df.P.E.（会被解释成连续的属性访问而出错），只能用 df[&#39;P.E.&#39;]。这再次说明了列名命名的规范性重要性。</p>
<p>改（修改列）： 修改列的值实际上和添加列是一样的操作——用新的值赋值给已有的列名。如果该列存在，就会被新值覆盖；如果不存在，就会新建列。因此在语法上没有专门的“改列”方法，直接赋值即可。</p>
<p>例如，我们可以把刚刚添加的 Chinese 列的分数全部改成 100：</p>
<pre><code class="language-python"><span class="line">df[&#39;Chinese&#39;] = [100, 100, 100, 100]</span>
<span class="line">print(df)</span>
<span class="line"># Chinese 列的值已更新为100:</span>
<span class="line">#   Name   Age Gender  Math  English  Chinese  P.E.</span>
<span class="line"># a   Tom  18.0      M   100     95.0      100    60</span>
<span class="line"># b Jerry  18.0    NaN   100     96.0      100    60</span>
<span class="line"># c  Jack  20.0      F   100      NaN      100    60</span>
<span class="line"># d  Rose   NaN      M   100     97.0      100    60</span></code></pre>
<p>这里将 df[&#39;Chinese&#39;] 直接赋值为新的列表，[100,100,100,100]，达到了修改整列的目的。同样地，你也可以只修改某几个值，比如使用按行索引的 .loc 来定位再赋值，这属于“行操作”范畴，我们稍后介绍。</p>
<p>删（删除列）： 删除 DataFrame 的列有多种方式：</p>
<ul>
<li>使用 <code>del df[&#39;列名&#39;]</code>，就像删除字典键一样。</li>
<li>使用 <code>df.pop(&#39;列名&#39;)</code>，会返回被删除的列的 Series。</li>
<li>使用 <code>df.drop(columns=[...])</code> 或 <code>df.drop([...], axis=1)</code>，可以一次删除一列或多列。drop 默认返回一个新的 DataFrame，除非指定 inplace=True 原地删除。</li>
</ul>
<p>下面依次演示用上述方法删除我们不需要的列：</p>
<pre><code class="language-python"><span class="line"># 1. del 关键字删除列</span>
<span class="line">del df[&#39;P.E.&#39;]</span>
<span class="line">print(df.columns)  # Index([&#39;Name&#39;, &#39;Age&#39;, &#39;Gender&#39;, &#39;Math&#39;, &#39;English&#39;, &#39;Chinese&#39;], dtype=&#39;object&#39;)</span>
<span class="line"></span>
<span class="line"># 2. pop 方法删除列</span>
<span class="line">df.pop(&#39;Chinese&#39;)</span>
<span class="line">print(df.columns)  # Index([&#39;Name&#39;, &#39;Age&#39;, &#39;Gender&#39;, &#39;Math&#39;, &#39;English&#39;], dtype=&#39;object&#39;)</span>
<span class="line"></span>
<span class="line"># 3. drop 删除多列</span>
<span class="line">df.drop([&#39;Math&#39;, &#39;English&#39;], axis=1, inplace=True)</span>
<span class="line">print(df.columns)  # Index([&#39;Name&#39;, &#39;Age&#39;, &#39;Gender&#39;], dtype=&#39;object&#39;)</span>
<span class="line">print(df)</span>
<span class="line">#    Name   Age Gender</span>
<span class="line"># a   Tom  18.0      M</span>
<span class="line"># b Jerry  18.0    NaN</span>
<span class="line"># c  Jack  20.0      F</span>
<span class="line"># d  Rose   NaN      M</span></code></pre>
<p>可以看到，先用 del 删掉了 P.E. 列，然后用 pop 删掉 Chinese 列，最后用 drop 一次性删掉 Math 和 English 列。删除后我们的 DataFrame 又只剩下最初的三列（Name, Age, Gender）以及原来的行索引。使用 drop 时记得加 axis=1 表示按列删除，并且可以根据需要选择是否 inplace。如果不使用 inplace，那么应当用 df = df.drop([...], axis=1) 赋值回去，因为 drop 默认返回删除指定列后的新 DataFrame。</p>
<h2>行操作 CRUD</h2>
<p>有时候我们需要对表格的行进行操作，例如按行查看数据、添加或删除某些行等。行的操作在 Pandas 中主要通过索引（index）来定位，分为按标签索引（index label）和按整数位置索引两大方式。</p>
<p>对行的“查、增、改、删”，我们分别介绍。继续使用前面的 DataFrame（目前有 Name, Age, Gender 列，索引 a, b, c, d），来演示行操作。</p>
<p>查（读取行）： 和列不同，直接使用 df[...] 的方括号不能直接按行标签取行。比如 df[&#39;a&#39;] 并不会返回索引为 a 的那一行，而是试图取名为 ‘a’ 的列（通常不存在，会报错）。因此，Pandas 提供了专门的索引器属性：</p>
<ul>
<li><code>df.loc[行标签]</code> 用行标签选取数据。</li>
<li><code>df.iloc[行号]</code> 用行位置（整数下标）选取数据。</li>
</ul>
<p>这两个索引器非常重要：loc 基于标签，iloc 基于整数位置。使用它们我们可以非常灵活地按行或按行列组合选取数据。</p>
<p>loc 用法示例：</p>
<pre><code class="language-python"><span class="line"># 使用 loc 按标签索引行</span>
<span class="line">print(df.loc[&#39;a&#39;])         # 索引为 &#39;a&#39; 的整行数据，返回一个 Series</span>
<span class="line">print(df.loc[&#39;b&#39;:&#39;c&#39;])     # 从索引 &#39;b&#39; 到 &#39;c&#39; 的行（包括 &#39;c&#39; 行）</span>
<span class="line">print(df.loc[[&#39;a&#39;, &#39;c&#39;], [&#39;Name&#39;, &#39;Gender&#39;]])</span>
<span class="line"># 上面一行选取索引 a 和 c 的两行，且只取其中的 Name 和 Gender 两列</span></code></pre>
<p>iloc 用法示例：</p>
<pre><code class="language-python"><span class="line"># 使用 iloc 按位置索引行</span>
<span class="line">print(df.iloc[0])          # 第 0 号位置的行（即索引 &#39;a&#39; 这一行）</span>
<span class="line">print(df.iloc[1:3])        # 位置 1 到 2 的行（不包括位置3），对应索引 b, c 两行</span>
<span class="line">print(df.iloc[[0, 2], [0, 2]])</span>
<span class="line"># 上面一行选取位置 0 和 2 的两行，以及位置 0 和 2 的两列，实现行列交叉选取</span></code></pre>
<p>loc 和 iloc 都可以接受单个索引、切片、列表等形式来选取多行/多列，非常灵活。需要注意几点：</p>
<ul>
<li>用 loc 做标签切片时，区间两端都是闭区间，也就是包含结束标签。例如上例中 <code>df.loc[&#39;b&#39;:&#39;c&#39;]</code> 包含 ‘c’ 行。</li>
<li>用 iloc 做位置切片则和 Python 列表切片规则一致，左闭右开，不包含结束的索引位置。</li>
<li>iloc 允许索引列表中有重复值或顺序打乱，这种情况下会相应返回重复或乱序的行。这在需要根据位置重复数据时可能有用。</li>
<li>如果 DataFrame 的索引是数字且你用 df[some_number] 直接索引，Pandas会优先尝试按标签解析（因为索引可能正好是那个数字）。因此当索引是数字时，要特别注意区分 loc（按标签）和默认的[]行为。最安全的做法是始终使用 loc 或 iloc 来取行，避免歧义。</li>
</ul>
<p>增（添加行）： DataFrame 添加行相对没有添加列那么直接。以往 Pandas 有 df.append() 方法可以直接添加一行新的数据，但自 Pandas 1.4 起该方法已被废弃，官方建议使用 pd.concat 来完成这一功能。</p>
<p>添加新行的思路是：先构造一个与原 DataFrame 列结构相同的 DataFrame 或 Series，然后通过 <code>pd.concat([...], axis=0)</code> 将其与原 DataFrame 按行拼接。注意保持新行的数据在列上的对齐。下面演示添加一行数据：</p>
<pre><code class="language-python"><span class="line"># 构造一行新数据，注意列名需与原 DataFrame 一致</span>
<span class="line">new_row = pd.DataFrame([[&#39;ZhangSan&#39;, 21, &#39;M&#39;]], </span>
<span class="line">                       columns=[&#39;Name&#39;, &#39;Age&#39;, &#39;Gender&#39;], </span>
<span class="line">                       index=[&#39;e&#39;])</span>
<span class="line"># 用 concat 连接新行</span>
<span class="line">df = pd.concat([df, new_row], axis=0)</span>
<span class="line">print(df)</span>
<span class="line"># 输出:</span>
<span class="line">#    Name   Age Gender</span>
<span class="line"># a    Tom  18.0      M</span>
<span class="line"># b  Jerry  18.0    NaN</span>
<span class="line"># c   Jack  20.0      F</span>
<span class="line"># d   Rose   NaN      M</span>
<span class="line"># e ZhangSan 21.0      M</span></code></pre>
<p>上面我们添加了一行索引为 ‘e’ 的数据，Name 为 ZhangSan，Age 为21，Gender 为 M。拼接后可以看到 df 多了一行 ‘e’。如果不指定 index=[&#39;e&#39;]，new_row 会默认用0作为索引，与原 DataFrame 的索引类型不一致甚至冲突。在这种情况下 concat 仍会成功（它不会因为索引重复而报错），但新行索引会是0，有可能与原有索引冲突导致两个索引相同。这通常不是我们想要的，所以指定一个不会重复的新索引比较安全。</p>
<p>改（修改行）： 修改行通常可以通过 loc 或 iloc 来定位整行然后赋值。例如，我们把刚才添加的 ‘e’ 行数据的 Name 和 Age 修改一下：</p>
<pre><code class="language-python"><span class="line">df.loc[&#39;e&#39;] = [&#39;Peter&#39;, 22.0, &#39;M&#39;]  # 将索引 &#39;e&#39; 的整行重置为新的值</span>
<span class="line">print(df.loc[&#39;e&#39;])</span>
<span class="line"># 输出:</span>
<span class="line"># Name      Peter</span>
<span class="line"># Age        22.0</span>
<span class="line"># Gender        M</span>
<span class="line"># Name: e, dtype: object</span></code></pre>
<p>我们成功地把索引 e 那行的数据更新为 Name = Peter, Age = 22.0, Gender = ‘M’。这里直接对 df.loc[&#39;e&#39;] 赋予一个列表，新值会按照列的顺序填入对应的三个列。如果只想修改某个单元格，也可以使用 <code>df.at[row_index, col_name] = value</code> 或 <code>df.iat[row_position, col_position] = value</code> 来定位赋值。</p>
<p>删（删除行）： 删除行使用 drop 方法，指定 axis=0（或者不指定，默认就是0也表示按行删）。可以传入要删除的索引标签列表。与删除列类似，drop 默认返回新对象，除非设置 inplace=True。示例：</p>
<pre><code class="language-python"><span class="line"># 删除索引为 &#39;b&#39; 和 &#39;d&#39; 的两行</span>
<span class="line">df = df.drop([&#39;b&#39;, &#39;d&#39;], axis=0)</span>
<span class="line">print(df)</span>
<span class="line"># 输出:</span>
<span class="line">#    Name   Age Gender</span>
<span class="line"># a   Tom  18.0      M</span>
<span class="line"># c  Jack  20.0      F</span>
<span class="line"># e Peter  22.0      M</span></code></pre>
<p>索引 b 和 d 的行被删除了。可以看到现在 DataFrame 只剩下 a, c, e 三行数据。如果索引是默认的整数且希望按位置删除第几行，也可以直接传索引值（因为默认索引标签就是数字）。例如 df.drop([0], axis=0) 会删除索引为0的行。但是一旦索引不是默认整序，还是应该用标签。另外，如果想按条件删除（比如删除 Age 大于20的行），可以构造一个布尔型索引掩码然后用 <code>df.drop(df[condition].index, axis=0)</code> 实现，这里不展开。</p>
<h2>CSV 文件读写实践</h2>
<p>数据通常保存在文件中，Pandas 支持读取和保存多种格式的数据文件，其中CSV（Comma-Separated Values）是最常见的文本格式。下面我们介绍 Pandas 如何高效地读取CSV，以及一些常用参数和技巧。同样，写回CSV也非常简单。</p>
<p>读取 CSV： 使用 pd.read_csv 函数即可读取CSV文件，基本用法是传入文件路径，Pandas 会自动将其解析为 DataFrame。示例：</p>
<pre><code class="language-python"><span class="line">import pandas as pd</span>
<span class="line"></span>
<span class="line"># 基本读取（假设 CSV 第一行为表头）</span>
<span class="line">df = pd.read_csv(&#39;data.csv&#39;)</span>
<span class="line">print(df.head(5))  # 查看前5行</span></code></pre>
<p>如果CSV文件包含表头（第一行是列名），pd.read_csv 会自动将其作为列名。如果CSV没有表头行，我们需要告诉函数不要将第一行当作列名，可以使用 header=None，同时通过 names= 指定列名列表。例如：</p>
<pre><code class="language-python"><span class="line"># 如果 CSV 没有表头行，指定 header=None 并提供列名</span>
<span class="line">df = pd.read_csv(&#39;data_no_header.csv&#39;, header=None, names=[&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;])</span></code></pre>
<p>read_csv 还有许多有用的参数，常用的包括：</p>
<ul>
<li>sep：指定分隔符，默认是逗号,。如果是制表符分隔的文件，可以用 sep=&#39;\t&#39;。</li>
<li>header：用来指定哪一行作为列名。如果第一行是数据而非列名，用 header=None。</li>
<li>names：当没有表头或者想自行指定列名时，用这个参数传入列表作为列名。</li>
<li>index_col：指定将某一列读入时设置为行索引。例如 index_col=&#39;Date&#39; 会将”Date”那列作为索引而不是普通数据列。</li>
<li>usecols：可以传入一个列名列表，表示只读取这些列，忽略其他列。对于很大的文件，读取必要的列可以明显加快速度、节省内存。</li>
<li>dtype：可以指定列的数据类型，比如将某列强制读成字符串 dtype={&#39;col&#39;: str}。正确指定类型也有助于加快读取和减少内存占用。</li>
<li>nrows：只读取前 n 行，用于预览大型文件或测试。</li>
<li>encoding：指定文件编码，比如中文常用 encoding=&#39;utf-8&#39;（默认）、&#39;gbk&#39; 等。</li>
<li>engine：解析引擎，一般不用特别指定。只有在分隔符比较特殊（例如多字符）时，会用到 engine=&#39;python&#39;。</li>
</ul>
<p>我们将上述一些参数综合在一个例子里：假设有一个文件包含股票数据，没有列名，我们想读取其中的日期(date)作为索引，以及开盘价(open)、最高价(high)、最低价(low)、收盘价(close)这几列。文件用逗号分隔。读取代码可以这么写：</p>
<pre><code class="language-python"><span class="line">df = pd.read_csv(&#39;aapl.csv&#39;,</span>
<span class="line">                 sep=&#39;,&#39;,         # 分隔符为逗号</span>
<span class="line">                 header=None,     # 文件中无表头行</span>
<span class="line">                 names=[&#39;name&#39;, &#39;date&#39;, &#39;_&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],  # 列名列表</span>
<span class="line">                 index_col=&#39;date&#39;,# 将&quot;date&quot;列作为行索引</span>
<span class="line">                 usecols=[&#39;date&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;]  # 只读取需要的五列</span>
<span class="line">)</span>
<span class="line">print(df.head(3))</span>
<span class="line"># 输出示例:</span>
<span class="line">#             open    high     low   close</span>
<span class="line"># date</span>
<span class="line"># 2011-01-28  344.17  344.40  333.53  336.10</span>
<span class="line"># 2011-01-31  335.80  340.04  334.30  339.32</span>
<span class="line"># 2011-02-01  341.30  345.65  340.98  345.03</span></code></pre>
<p>在这个例子中，我们通过 names 提供了8个列名（文件每行有8个字段，其中第三个字段我们命名为_表示我们不关心），然后用 usecols 选择了我们想要的5列数据（date 和 OHLC 四列），并将 date 列设为索引。head(3) 打印输出验证了读取效果。使用 usecols 有效避免了读取不需要的数据，提高了速度。</p>
<blockquote>
<p><strong>常见问题</strong>： <em>“如果 CSV 有五万行，那么用 Pandas 读会不会很慢、很卡？”</em></p>
<p><strong>答案是：不会</strong>。 五万行对 Pandas 而言不算很多，一般几百毫秒就能读完。不过如果数据达到上百万行乃至更大，内存和耗时就需要考虑。这种情况下可以使用分块读取：pd.read_csv(..., chunksize=10000) 会返回一个可迭代的 TextFileReader，每次读取10000行，我们可以遍历每个chunk逐步处理。这样可以避免一次性占用太多内存。另一个方法是使用 dtype 精确指定类型，避免Pandas猜测类型的开销和潜在的不必要的高精度类型。总的来说，对于超大文件，分块读取并逐步处理是常用策略。</p>
</blockquote>
<p>写出 CSV： 将 DataFrame 保存为 CSV 使用 DataFrame.to_csv 方法即可。例如：</p>
<pre><code class="language-python"><span class="line">df.to_csv(&#39;output.csv&#39;, index=False)</span></code></pre>
<p>上面代码将 DataFrame 写入当前目录下的 output.csv 文件，并设置 index=False 表示不保存行索引（因为有些情况下行索引没意义或者不要导出）。默认情况下 to_csv 会保存行索引和列标签，如果不想要可以分别用 index=False 和 header=False 关闭。to_csv 也支持 sep, encoding 等参数，自行根据需要设置即可。</p>
<p>除了 CSV 之外，Pandas 也支持读取/写入多种常见格式：</p>
<ul>
<li>Excel：使用 pd.read_excel(&#39;file.xlsx&#39;) 读取，DataFrame.to_excel(&#39;out.xlsx&#39;) 写入。注意读取 Excel 需要安装相应的引擎库，如 openpyxl。一般 .xlsx 文件都会用 openpyxl 引擎。</li>
<li>JSON：使用 pd.read_json(&#39;file.json&#39;) 读取，DataFrame.to_json(&#39;out.json&#39;) 写出。read_json 可以通过参数 orient 来指定 JSON 的组织格式（比如记录为行还是列）。</li>
<li>SQL：使用 pd.read_sql(query, connection) 可以从数据库读取查询结果为 DataFrame，to_sql 可以写入数据库表。（这需要SQLAlchemy等支持，这里略过）</li>
<li>以及其它格式例如 Parquet (read_parquet)、HTML表(read_html)、Stata (read_stata) 等等。</li>
</ul>
<p>简单来说，Pandas 提供了一套统一的高层接口来读取和存储数据，让数据在不同媒介之间转移变得非常方便。你可以将其视为数据转换的瑞士军刀：CSV、Excel、JSON 转DataFrame，DataFrame再转回各种格式，都不是问题。</p>
<h2>总结</h2>
<p>Pandas 的两个核心数据结构：Series（一维带索引数组）和 DataFrame（二维表格）。在实际工程中，Pandas 可以大幅提高我们处理表格数据的效率。遇到“表格里的列名有空格”这样的细节问题，我们知道可以通过更换访问方式或重命名来解决；面对“怎样读大文件不卡”这样的性能问题，我们也了解了分块读取等方案。熟悉这些技巧能让我们更加游刃有余地使用 Pandas 处理数据。</p>

    </article>
    </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
<script>
Prism.highlightAll();
document.querySelectorAll('article pre').forEach(pre => {
    const code = pre.querySelector('code');
    if (!code) return;
    const toolbar = document.createElement('div');
    toolbar.className = 'code-toolbar';
    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = () => {
        navigator.clipboard.writeText(code.textContent).then(() => {
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000);
        });
    };
    toolbar.appendChild(btn);
    pre.parentNode.insertBefore(toolbar, pre);
});
</script>
</body>
</html>