<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automating an Astro Blog with a Python MCP Server: A Hands-On Guide</title>
    <style>
        body { font-family: Georgia, serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; line-height: 1.7; color: #333; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        h2 { font-size: 1.4rem; margin-top: 2rem; }
        pre { background: #f4f4f4; padding: 1rem; overflow-x: auto; border-radius: 4px; }
        code { font-family: Menlo, Monaco, monospace; font-size: 0.9em; }
        p code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; }
        img { max-width: 100%; }
        blockquote { border-left: 3px solid #ddd; margin-left: 0; padding-left: 1rem; color: #666; }
        ul { padding-left: 1.5rem; }
        hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        a { color: #1a8917; }
    </style>
</head>
<body>
<hr>
<h2>date: 2025-07-27
tags: [devops, mcp, python, astro, automation, fastmcp]
legacy: true</h2>
<h1>Automating an Astro Blog with a Python MCP Server: A Hands-On Guide</h1>
<p>Before diving into the code, let&#39;s get to know the core library, <code>fastmcp</code>. You can think of it as a magic wand: with a simple wave over a standard Python function (i.e., by using a decorator), that function is instantly wrapped into an MCP-compliant tool, ready to be called by an AI client.</p>
<p>The design philosophy of <code>FastMCP</code> is &quot;minimalist yet powerful.&quot; It handles all the low-level details of the MCP protocol for you, such as JSON-RPC communication, tool discovery, and asynchronous execution. The only thing a developer needs to do is focus on writing the business logic of the tool functions.</p>
<p>In our script, the use of <code>FastMCP</code> is demonstrated in these two core lines of code:</p>
<blockquote><code># 1. Initialize an MCP application instance</code><br>
<code>app = FastMCP(</code><br>
<code>    name=&quot;Astro Deployment MCP Server&quot;,</code><br>
<code>    instructions=&quot;Exposes publish_article and commit_code tools for an Astro blog&quot;,</code><br>
<code>)</code><br>
<code></code><br>
<code># 2. Register a function as a tool using the @app.tool() decorator</code><br>
<code>@app.tool()</code><br>
<code>async def my_tool_function():</code><br>
<code>    # ... tool logic ...</code><br>
<code>    return &quot;Tool execution result&quot;</code></blockquote><p>The <code>name</code> and <code>instructions</code> fields are metadata that tell the MCP client the purpose of this server and the capabilities it offers, which is very helpful for the AI to understand the context. The <code>@app.tool()</code> decorator is the heart of it all, automatically registering any <code>async</code> function it decorates as a tool that can be called remotely.</p>
<h2>The Goal: Automating the Astro Blog Workflow</h2>
<p>Our goal is clear: to enable an AI to independently complete the entire process of publishing a new blog post. This process can be broken down into three core actions:</p>
<ol>
<li><strong>Save the Article</strong>: Save the AI-generated Markdown content to the specified directory in the Astro project.</li>
<li><strong>Commit the Code</strong>: Stage (<code>add</code>), commit (<code>commit</code>), and push (<code>push</code>) the newly added article file using Git.</li>
<li><strong>Publish the Website</strong>: Execute the deployment command to publish the latest blog content to the live server.</li>
</ol>
<p>Next, we will analyze the tool functions that implement these three actions one by one.</p>
<h2>Code Implementation Deep Dive</h2>
<p>Our MCP server is a standalone Python script, <code>astro_mcp_server.py</code>. Let&#39;s examine its structure.</p>
<h3>1. Environment Configuration and Helper Functions</h3>
<p>The script&#39;s first task is to determine the root directory of the Astro blog project. By reading the <code>ASTRO_DIR</code> environment variable, we achieve configuration flexibility while providing a default value of <code>./astro</code>. The script cleverly uses the <code>pathlib</code> library, which is the modern best practice for handling file paths in Python.</p>
<blockquote><code>import os</code><br>
<code>import pathlib</code><br>
<code></code><br>
<code># Configuration</code><br>
<code>ASTRO_DIR = pathlib.Path(os.getenv(&quot;ASTRO_DIR&quot;, &quot;./astro&quot;)).expanduser().resolve()</code><br>
<code>if not ASTRO_DIR.is_dir():</code><br>
<code>    raise RuntimeError(</code><br>
<code>        f&quot;ASTRO_DIR {ASTRO_DIR} does not exist or is not a directory&quot;</code><br>
<code>    )</code></blockquote><p>To avoid repetitive code for executing command-line instructions in each tool function, we define a helper function <code>_run</code>. It uses <code>subprocess.run</code> to execute commands in the specified <code>ASTRO_DIR</code>, capturing their standard output and error streams. The returned log includes the command that was executed, which is invaluable for debugging and tracking.</p>
<blockquote><code>import subprocess</code><br>
<code>from typing import List</code><br>
<code></code><br>
<code>def _run(cmd: List[str]) -&gt; str:</code><br>
<code>    &quot;&quot;&quot;Runs a command in ASTRO_DIR and returns its output.&quot;&quot;&quot;</code><br>
<code>    proc = subprocess.run(cmd, cwd=ASTRO_DIR, capture_output=True, text=True)</code><br>
<code>    banner = f&quot;$ {&#039; &#039;.join(cmd)}\n&quot;</code><br>
<code>    return banner + proc.stdout + proc.stderr</code></blockquote><h3>2. Tool #1: <code>save_article</code> - Intelligently Saving Articles</h3>
<p>This is one of the most crucial tools. It accepts a directory, filename, and article content as parameters and writes them to a file.</p>
<blockquote><code>@app.tool()</code><br>
<code>async def save_article(directory: str, content: str, filename: str) -&gt; str:</code><br>
<code>    &quot;&quot;&quot;Save article content to a file in the specified directory within ASTRO_DIR.&quot;&quot;&quot;</code><br>
<code>    import datetime</code><br>
<code>    </code><br>
<code>    target_dir = ASTRO_DIR / directory</code><br>
<code>    target_dir.mkdir(parents=True, exist_ok=True)</code><br>
<code>    </code><br>
<code># ... (23 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>The most impressive part of this function is its logic for <strong>intelligently adding frontmatter</strong>. Frontmatter is the block used by static site generators (like Astro, Hugo, and Jekyll) to define page metadata such as title and publication date. The logic in this script is as follows:</p>
<ol>
<li>Check if the file is a Markdown file (<code>.md</code> or <code>.mdx</code>).</li>
<li>Check if the content already includes frontmatter (<code>---</code>).</li>
<li>If frontmatter needs to be added, it intelligently infers the article title: it defaults to using the filename, but if an H1 heading (<code># </code>) is found within the first few lines of the article, it will use that H1 as the title.</li>
<li>It automatically generates frontmatter containing the title, current date, a description, and the author, and prepends it to the article content.</li>
</ol>
<p>This small feature greatly improves the quality of AI-generated articles, freeing the AI client from worrying about the details of frontmatter formatting.</p>
<h3>3. Tool #2: <code>commit_code</code> - Automating Version Control</h3>
<p>Once the article is saved, the next step is to get it into version control. The <code>commit_code</code> tool encapsulates the standard Git workflow.</p>
<blockquote><code>@app.tool()</code><br>
<code>async def commit_code(message: str = &quot;chore: automated commit&quot;) -&gt; str:</code><br>
<code>    &quot;&quot;&quot;Stage, commit, and push code changes in ASTRO_DIR.&quot;&quot;&quot;</code><br>
<code>    outputs: List[str] = []</code><br>
<code>    </code><br>
<code>    outputs.append(_run([&quot;git&quot;, &quot;add&quot;, &quot;-A&quot;]))</code><br>
<code>    </code><br>
<code>    commit_result = _run([&quot;git&quot;, &quot;commit&quot;, &quot;-m&quot;, message])</code><br>
<code># ... (8 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>This function executes <code>git add -A</code>, <code>git commit</code>, and <code>git push</code> in sequence. It also includes a practical check: it only executes <code>git push</code> if <code>git commit</code> successfully created a new commit (i.e., the output does not contain &quot;nothing to commit&quot;), thus avoiding unnecessary push operations. The function&#39;s return value is the complete output of all Git commands, allowing the AI client to understand the status of each step.</p>
<h3>4. Tool #3: <code>publish_article</code> - One-Click Publishing</h3>
<p>This is the simplest tool, but it delivers the final, critical step. It does only one thing: execute the deployment command.</p>
<blockquote><code>@app.tool()</code><br>
<code>async def publish_article() -&gt; str:</code><br>
<code>    &quot;&quot;&quot;Deploy the Astro blog to production by running npm run deploy.&quot;&quot;&quot;</code><br>
<code>    return _run([&quot;npm&quot;, &quot;run&quot;, &quot;deploy&quot;])</code></blockquote><p>This tool assumes that your Astro project&#39;s <code>package.json</code> file has a script named <code>deploy</code> defined, which handles all the logic for building and deploying to the production environment (e.g., pushing to Vercel, Netlify, or your own server). This design decouples the complexity of deployment from the MCP server itself, making it very flexible.</p>
<h2>How to Run and Use It</h2>
<p>Now that we have a full set of tools, how do we get it working?</p>
<h3>1. Prerequisites</h3>
<ul>
<li>Ensure you have Python 3 installed on your system.</li>
<li>Install the <code>fastmcp</code> library: <code>pip install fastmcp</code>.</li>
<li>Prepare an Astro blog project and make sure it&#39;s a Git repository.</li>
<li>In your Astro project&#39;s <code>package.json</code>, add a <code>deploy</code> script. For example:<blockquote><code>&quot;scripts&quot;: {</code><br>
<code>  &quot;dev&quot;: &quot;astro dev&quot;,</code><br>
<code>  &quot;start&quot;: &quot;astro dev&quot;,</code><br>
<code>  &quot;build&quot;: &quot;astro build&quot;,</code><br>
<code>  &quot;preview&quot;: &quot;astro preview&quot;,</code><br>
<code>  &quot;deploy&quot;: &quot;astro build &amp;&amp; gh-pages -d dist --branch gh-pages&quot;</code><br>
<code>}</code></blockquote></li>
</ul>
<h3>2. Run the MCP Server</h3>
<ul>
<li>Place the <code>astro_mcp_server.py</code> script in your workspace.</li>
<li>In your terminal, set the <code>ASTRO_DIR</code> environment variable to point to your blog&#39;s root directory:<p><code>export ASTRO_DIR=&quot;/path/to/your/astro-blog&quot;</code></p></li>
<li>Run the script:<p><code>python3 astro_mcp_server.py</code></p></li>
</ul>
<p>After execution, the script will not produce any output; it will wait silently in the background for MCP instructions from standard input.</p>
<h3>3. Interact with an MCP Client</h3>
<p>This script is a &quot;server&quot;; it needs a &quot;client&quot; to communicate with. This client is typically the execution environment where the AI agent resides. The client will launch <code>astro_mcp_server.py</code> as a subprocess, then send JSON-RPC formatted requests through the process&#39;s standard input (stdin) and read the results from its standard output (stdout).</p>
<p>For example, when an AI client wants to call the <code>save_article</code> tool, it might write JSON data like the following to the script&#39;s stdin:</p>
<blockquote><code>{</code><br>
<code>  &quot;jsonrpc&quot;: &quot;2.0&quot;, </code><br>
<code>  &quot;method&quot;: &quot;save_article&quot;, </code><br>
<code>  &quot;params&quot;: {</code><br>
<code>    &quot;directory&quot;: &quot;src/content/blog&quot;, </code><br>
<code>    &quot;filename&quot;: &quot;new-ai-article.md&quot;, </code><br>
<code>    &quot;content&quot;: &quot;# A New Beginning\n\nThis is my first article written by AI!&quot;</code><br>
<code>  }, </code><br>
<code>  &quot;id&quot;: 1</code><br>
<code>}</code></blockquote><p>Upon receiving the instruction, the script will execute the corresponding <code>save_article</code> function and write the result (a success message or an error) back to stdout in the JSON-RPC response format for the client to parse.</p>
<h2>Conclusion</h2>
<p>With a Python script of less than 100 lines, we successfully built a powerful, automated MCP server for an Astro blog. This case study perfectly illustrates the &quot;less is more&quot; engineering philosophy:</p>
<ul>
<li><strong>Simple and Direct</strong>: A pure Python script with no complex frameworks or configuration.</li>
<li><strong>Single Responsibility</strong>: Focuses solely on providing tools for interacting with the blog, without handling other unrelated logic.</li>
<li><strong>Leverages Existing Tools</strong>: Cleverly wraps mature command-line tools like <code>git</code> and <code>npm</code> via <code>subprocess</code> instead of reinventing the wheel in Python.</li>
<li><strong>Highly Extensible</strong>: Need a new feature? Just add a new function decorated with <code>@app.tool()</code>.</li>
</ul>
<p>This pattern is not limited to Astro blogs. You can easily adapt it to automate any workflow that can be manipulated via the command line or scriptsâ€”whether it&#39;s managing cloud services, operating databases, or controlling local IoT devices. MCP and <code>FastMCP</code> open a door for us, allowing AI to integrate more deeply and seamlessly into our digital lives and work.</p>

</body>
</html>