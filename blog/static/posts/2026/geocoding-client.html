<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Production-Ready Geocoding Client: Coordinate Hacks, Connection Pools, and Rate Limiting | Yuxu Ge</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --black: #111;
            --dark-grey: #444;
            --off-white: #f4f4f4;
            --vermilion: #C41E3A;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--black);
            background-color: var(--off-white);
        }

        a { color: var(--vermilion); text-decoration: none; }
        a:hover { opacity: 0.75; }

        .layout { min-height: 100vh; }

        /* Sidebar */
        .sidebar {
            position: fixed; top: 0; left: 0;
            width: 320px; height: 100vh;
            background: var(--black); color: var(--off-white);
            padding: 3rem 2rem;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .sidebar-top { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .avatar { display: block; width: 120px; height: 120px; border-radius: 50%; border: 3px solid var(--vermilion); margin-bottom: 1.5rem; overflow: hidden; transition: transform 0.2s ease; }
        .avatar:hover { opacity: 1; transform: scale(1.05); }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .name-block { margin-bottom: 0.5rem; }
        h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: 1px; color: var(--off-white); }
        .title-role { font-size: 0.9rem; color: #888; margin-top: 0.25rem; font-weight: 400; }
        .contact-block { margin-top: 2.5rem; width: 100%; }
        .social-links { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .social-links a { display: flex; align-items: center; gap: 0.75rem; width: 160px; color: var(--off-white); opacity: 0.7; padding: 0.5rem 0.75rem; border-radius: 4px; font-size: 0.9rem; transition: all 0.2s; }
        .social-links a:hover { color: var(--vermilion); opacity: 1; background: rgba(255,255,255,0.05); }
        .social-links svg { width: 20px; height: 20px; flex-shrink: 0; }
        .social-links .orcid-link { font-size: 0.68rem; gap: 0.5rem; white-space: nowrap; }
        .sidebar-footer { text-align: center; font-size: 0.75rem; color: #555; }

        /* Content */
        .content { margin-left: 320px; padding: 3rem 4rem; max-width: 900px; }
        .back-link { display: inline-block; font-size: 0.85rem; margin-bottom: 2rem; color: var(--dark-grey); }
        .back-link:hover { color: var(--vermilion); }

        /* Article */
        article h1 { font-size: 2rem; font-weight: 700; margin-bottom: 1.5rem; line-height: 1.3; color: var(--black); }
        article h2 { font-size: 1.4rem; font-weight: 600; margin: 2rem 0 1rem; color: var(--black); }
        article h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; color: var(--black); }
        article p { margin-bottom: 1rem; color: var(--dark-grey); }
        article ul, article ol { margin: 1rem 0 1rem 1.5rem; color: var(--dark-grey); }
        article li { margin-bottom: 0.5rem; }
        article strong { color: var(--black); }
        article code { font-family: "SF Mono", Monaco, monospace; font-size: 0.9em; background: #e8e8e8; padding: 0.15em 0.4em; border-radius: 3px; }
        article pre { margin: 1rem 0; border-radius: 6px; overflow-x: auto; background: #2d2d2d; padding: 1rem; }
        article pre code { background: none; padding: 0; font-size: 0.75em; white-space: pre !important; counter-reset: line; display: block; color: #ccc; }
        article pre code .line { counter-increment: line; }
        article pre code .line::before { content: counter(line); display: inline-block; width: 2.5em; margin-right: 1em; text-align: right; color: #666; user-select: none; }
        .code-toolbar { display: flex; justify-content: flex-start; padding: 0.35rem 0.5rem; background: #3a3a3a; border-radius: 6px 6px 0 0; }
        .code-toolbar + pre { margin-top: 0; border-radius: 0 0 6px 6px; }
        .copy-btn { padding: 0.2rem 0.5rem; font-size: 0.7rem; background: #555; color: #fff; border: none; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
        .copy-btn:hover, .copy-btn:active { background: #777; }
        .copy-btn.copied { background: #2a2; }
        article blockquote { border-left: 3px solid var(--vermilion); padding-left: 1rem; margin: 1rem 0; color: #666; font-style: italic; }
        article hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        article table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        article th, article td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
        article th { background: #e8e8e8; font-weight: 600; }
        article img { max-width: 100%; height: auto; display: block; margin: 1.5rem 0; border-radius: 6px; }

        .loading { text-align: center; padding: 3rem; color: #888; }
        .error { color: var(--vermilion); }

        /* KaTeX math styles */
        .katex-display { overflow-x: auto; overflow-y: hidden; padding: 0.5rem 0; }
        .katex { font-size: 1.1em; }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { position: relative; width: 100%; height: auto; padding: 2rem 1.5rem 1rem; }
            .social-links { flex-direction: row; flex-wrap: wrap; justify-content: center; }
            .social-links a, .social-links .orcid-link { width: auto; padding: 0.5rem; font-size: 0; gap: 0; }
            .social-links svg { width: 24px; height: 24px; }
            .social-links .hide-mobile { display: none; }
            .sidebar-footer { margin-top: 1rem; }
            .content { margin-left: 0; padding: 2rem 1rem; }
        }
        @media (max-width: 480px) {
            .sidebar { padding: 1.5rem 1rem 1rem; }
            .avatar { width: 80px; height: 80px; }
            h1 { font-size: 1.4rem; }
            article h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="layout">
    <aside class="sidebar" id="sidebar-content"></aside>
    <script src="/components/sidebar.js"></script>

    <main class="content">
        <a href="/blog/" class="back-link">← Back to Blog</a>
        <article>
<hr>
<h2>date: 2026-01-26
tags: [python, backend, geospatial]
description: A deep dive into coordinate transformation (WGS84/GCJ02), connection pooling, rate limiting with token bucket, and retry strategies for geocoding APIs.</h2>
<h1>Building a Production-Ready Geocoding Client: Coordinate Hacks, Connection Pools, and Rate Limiting</h1>
<p>Geocoding looks simple: send an address, get coordinates back. But at scale, three hidden problems emerge that tutorials never mention:</p>
<ol>
<li><strong>In China, coordinates lie—by design</strong></li>
<li><strong>HTTP connections don&#39;t clean up after themselves</strong></li>
<li><strong>API quotas disappear faster than you&#39;d expect</strong></li>
</ol>
<p>I&#39;ve seen each of these take down production systems. This article shows how to build a geocoding client that handles all three.</p>
<hr>
<h2>Architecture Overview</h2>
<p>Before diving into details, here&#39;s how the pieces fit together:</p>
<p><img src="/blog/images/geocoding-client/architecture-diagram.png" alt="architecture-diagram"></p>
<p>Three modules, three problems solved. Let&#39;s examine each one.</p>
<hr>
<h2>Problem #1: The 300-Meter Coordinate Drift</h2>
<p>In China, consumer-facing maps don&#39;t use raw GPS coordinates (WGS-84). Instead, they use GCJ-02—nicknamed &quot;Mars Coordinates&quot;—which applies a non-linear offset to every point. This isn&#39;t a simple translation; it&#39;s a deliberate obfuscation involving trigonometric functions that shift coordinates by 50–500 meters depending on location.</p>
<p>If your backend receives WGS-84 coordinates from GPS devices but passes them directly to a Chinese mapping API, your pins will land in the wrong place. Delivery zones break. Geofences fail. Users complain that &quot;the map is wrong.&quot;</p>
<h3>The Solution: Iterative Inversion</h3>
<p>The GCJ-02 transformation has no closed-form inverse. We solve it numerically:</p>
<ol>
<li>Guess that WGS-84 ≈ GCJ-02 (good enough to start)</li>
<li>Apply the forward transformation to get a predicted GCJ-02</li>
<li>Measure the error and adjust</li>
<li>Repeat until error &lt; 10⁻⁶ degrees (~0.1 meter)</li>
</ol>
<pre><code class="language-python"><span class="line">import math</span>
<span class="line"></span>
<span class="line">_A = 6378245.0  # Semi-major axis</span>
<span class="line">_EE = 0.00669342162296594323  # First eccentricity squared</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">def _out_of_china(lng: float, lat: float) -&gt; bool:</span>
<span class="line">    &quot;&quot;&quot;Check if point is outside China (skip transformation).&quot;&quot;&quot;</span>
<span class="line">    return not (72.004 &lt;= lng &lt;= 137.8347 and 0.8293 &lt;= lat &lt;= 55.8271)</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">def _transform_lat(x: float, y: float) -&gt; float:</span>
<span class="line">    ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y</span>
<span class="line">    ret += 0.2 * math.sqrt(abs(x))</span>
<span class="line">    ret += (20.0 * math.sin(6.0 * x * math.pi) + </span>
<span class="line">            20.0 * math.sin(2.0 * x * math.pi)) * 2.0 / 3.0</span>
<span class="line">    ret += (20.0 * math.sin(y * math.pi) + </span>
<span class="line">            40.0 * math.sin(y / 3.0 * math.pi)) * 2.0 / 3.0</span>
<span class="line">    ret += (160.0 * math.sin(y / 12.0 * math.pi) + </span>
<span class="line">            320.0 * math.sin(y * math.pi / 30.0)) * 2.0 / 3.0</span>
<span class="line">    return ret</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">def _transform_lng(x: float, y: float) -&gt; float:</span>
<span class="line">    ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y</span>
<span class="line">    ret += 0.1 * math.sqrt(abs(x))</span>
<span class="line">    ret += (20.0 * math.sin(6.0 * x * math.pi) + </span>
<span class="line">            20.0 * math.sin(2.0 * x * math.pi)) * 2.0 / 3.0</span>
<span class="line">    ret += (20.0 * math.sin(x * math.pi) + </span>
<span class="line">            40.0 * math.sin(x / 3.0 * math.pi)) * 2.0 / 3.0</span>
<span class="line">    ret += (150.0 * math.sin(x / 12.0 * math.pi) + </span>
<span class="line">            300.0 * math.sin(x / 30.0 * math.pi)) * 2.0 / 3.0</span>
<span class="line">    return ret</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">def wgs84_to_gcj02(lng: float, lat: float) -&gt; tuple[float, float]:</span>
<span class="line">    &quot;&quot;&quot;Convert WGS-84 to GCJ-02 (forward transformation).&quot;&quot;&quot;</span>
<span class="line">    if _out_of_china(lng, lat):</span>
<span class="line">        return lng, lat</span>
<span class="line">    </span>
<span class="line">    dlat = _transform_lat(lng - 105.0, lat - 35.0)</span>
<span class="line">    dlng = _transform_lng(lng - 105.0, lat - 35.0)</span>
<span class="line">    </span>
<span class="line">    rad_lat = lat / 180.0 * math.pi</span>
<span class="line">    magic = math.sin(rad_lat)</span>
<span class="line">    magic = 1 - _EE * magic * magic</span>
<span class="line">    sqrt_magic = math.sqrt(magic)</span>
<span class="line">    </span>
<span class="line">    dlat = (dlat * 180.0) / ((_A * (1 - _EE)) / (magic * sqrt_magic) * math.pi)</span>
<span class="line">    dlng = (dlng * 180.0) / (_A / sqrt_magic * math.cos(rad_lat) * math.pi)</span>
<span class="line">    </span>
<span class="line">    return lng + dlng, lat + dlat</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">def gcj02_to_wgs84(lng: float, lat: float, </span>
<span class="line">                   tol: float = 1e-6, </span>
<span class="line">                   max_iter: int = 10) -&gt; tuple[float, float]:</span>
<span class="line">    &quot;&quot;&quot;Convert GCJ-02 back to WGS-84 via iterative refinement.&quot;&quot;&quot;</span>
<span class="line">    wgs_lng, wgs_lat = lng, lat</span>
<span class="line">    </span>
<span class="line">    for _ in range(max_iter):</span>
<span class="line">        pred_lng, pred_lat = wgs84_to_gcj02(wgs_lng, wgs_lat)</span>
<span class="line">        dlng = pred_lng - lng</span>
<span class="line">        dlat = pred_lat - lat</span>
<span class="line">        </span>
<span class="line">        if abs(dlng) &lt; tol and abs(dlat) &lt; tol:</span>
<span class="line">            break</span>
<span class="line">            </span>
<span class="line">        wgs_lng -= dlng</span>
<span class="line">        wgs_lat -= dlat</span>
<span class="line">    </span>
<span class="line">    return wgs_lng, wgs_lat</span></code></pre>
<p>The iteration converges in 2–3 steps for typical coordinates.</p>
<hr>
<h2>Problem #2: The TIME_WAIT Storm</h2>
<p>Every naive geocoding request creates a new TCP connection:</p>
<pre><code><span class="line">connect() → send HTTP request → receive response → close()</span></code></pre>
<p>At 500 QPS, this creates 500 connections per second. Each closed connection enters TIME_WAIT state for 60 seconds (Linux default). Do the math: 500 × 60 = 30,000 sockets stuck in TIME_WAIT, competing for the ~28,000 ephemeral ports available on a typical system.</p>
<p>Result: <code>OSError: [Errno 99] Cannot assign requested address</code></p>
<h3>The Solution: Connection Pooling + Exponential Backoff</h3>
<p>Replace stateless requests with a persistent session that reuses TCP connections:</p>
<pre><code class="language-python"><span class="line">import requests</span>
<span class="line">from requests.adapters import HTTPAdapter</span>
<span class="line">from urllib3.util.retry import Retry</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">def create_resilient_session(pool_size: int = 50) -&gt; requests.Session:</span>
<span class="line">    &quot;&quot;&quot;</span>
<span class="line">    Create an HTTP session with connection pooling and retry logic.</span>
<span class="line">    </span>
<span class="line">    Args:</span>
<span class="line">        pool_size: Max connections to keep alive (tune based on expected QPS)</span>
<span class="line">    &quot;&quot;&quot;</span>
<span class="line">    session = requests.Session()</span>
<span class="line">    </span>
<span class="line">    retry_strategy = Retry(</span>
<span class="line">        total=5,</span>
<span class="line">        backoff_factor=1,  # delays: 0s, 2s, 4s, 8s, 16s</span>
<span class="line">        status_forcelist=[429, 500, 502, 503, 504],</span>
<span class="line">        allowed_methods=[&quot;GET&quot;],</span>
<span class="line">    )</span>
<span class="line">    </span>
<span class="line">    adapter = HTTPAdapter(</span>
<span class="line">        max_retries=retry_strategy,</span>
<span class="line">        pool_connections=pool_size,</span>
<span class="line">        pool_maxsize=pool_size,</span>
<span class="line">    )</span>
<span class="line">    </span>
<span class="line">    session.mount(&quot;https://&quot;, adapter)</span>
<span class="line">    session.mount(&quot;http://&quot;, adapter)</span>
<span class="line">    </span>
<span class="line">    return session</span></code></pre>
<p><strong>Connection pool sizing</strong>: Use <code>pool_size = expected_QPS × average_latency</code>. At 500 QPS with 100ms latency, that&#39;s 50 connections.</p>
<hr>
<h2>Problem #3: Quota Burnout</h2>
<p>Commercial geocoding APIs have strict rate limits. Without client-side throttling, a traffic spike can exhaust your daily quota in minutes—then return HTTP 429 for the rest of the day.</p>
<h3>The Solution: Token Bucket Rate Limiting</h3>
<p>The token bucket algorithm enforces average rate while tolerating short bursts:</p>
<pre><code class="language-python"><span class="line">import threading</span>
<span class="line">import time</span>
<span class="line">from dataclasses import dataclass, field</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">@dataclass</span>
<span class="line">class TokenBucket:</span>
<span class="line">    &quot;&quot;&quot;</span>
<span class="line">    Local token bucket rate limiter.</span>
<span class="line">    For distributed systems, use Redis with Lua scripts.</span>
<span class="line">    &quot;&quot;&quot;</span>
<span class="line">    rate: float      # Tokens per second</span>
<span class="line">    capacity: float  # Max burst size</span>
<span class="line">    _tokens: float = field(init=False)</span>
<span class="line">    _timestamp: float = field(init=False)</span>
<span class="line">    _lock: threading.Lock = field(init=False)</span>
<span class="line">    </span>
<span class="line">    def __post_init__(self):</span>
<span class="line">        self._tokens = self.capacity</span>
<span class="line">        self._timestamp = time.time()</span>
<span class="line">        self._lock = threading.Lock()</span>
<span class="line">    </span>
<span class="line">    def acquire(self, tokens: int = 1) -&gt; bool:</span>
<span class="line">        with self._lock:</span>
<span class="line">            now = time.time()</span>
<span class="line">            self._tokens = min(</span>
<span class="line">                self.capacity,</span>
<span class="line">                self._tokens + (now - self._timestamp) * self.rate</span>
<span class="line">            )</span>
<span class="line">            self._timestamp = now</span>
<span class="line">            </span>
<span class="line">            if self._tokens &gt;= tokens:</span>
<span class="line">                self._tokens -= tokens</span>
<span class="line">                return True</span>
<span class="line">            return False</span></code></pre>
<p>Set <code>capacity = rate × 2</code> to allow 2 seconds of burst without risking quota exhaustion.</p>
<hr>
<h2>Complete Implementation</h2>
<p>Here&#39;s everything combined into a production-ready class:</p>
<pre><code class="language-python"><span class="line">import math</span>
<span class="line">import threading</span>
<span class="line">import time</span>
<span class="line">from dataclasses import dataclass, field</span>
<span class="line">from typing import Any</span>
<span class="line"></span>
<span class="line">import requests</span>
<span class="line">from requests.adapters import HTTPAdapter</span>
<span class="line">from urllib3.util.retry import Retry</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"># === Coordinate Transformation ===</span>
<span class="line"></span>
<span class="line">_A = 6378245.0</span>
<span class="line">_EE = 0.00669342162296594323</span>
<span class="line"></span>
<span class="line">def _out_of_china(lng: float, lat: float) -&gt; bool:</span>
<span class="line">    return not (72.004 &lt;= lng &lt;= 137.8347 and 0.8293 &lt;= lat &lt;= 55.8271)</span>
<span class="line"></span>
<span class="line">def _transform_lat(x: float, y: float) -&gt; float:</span>
<span class="line">    ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y</span>
<span class="line">    ret += 0.2 * math.sqrt(abs(x))</span>
<span class="line">    ret += (20.0 * math.sin(6.0 * x * math.pi) + </span>
<span class="line">            20.0 * math.sin(2.0 * x * math.pi)) * 2.0 / 3.0</span>
<span class="line">    ret += (20.0 * math.sin(y * math.pi) + </span>
<span class="line">            40.0 * math.sin(y / 3.0 * math.pi)) * 2.0 / 3.0</span>
<span class="line">    ret += (160.0 * math.sin(y / 12.0 * math.pi) + </span>
<span class="line">            320.0 * math.sin(y * math.pi / 30.0)) * 2.0 / 3.0</span>
<span class="line">    return ret</span>
<span class="line"></span>
<span class="line">def _transform_lng(x: float, y: float) -&gt; float:</span>
<span class="line">    ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y</span>
<span class="line">    ret += 0.1 * math.sqrt(abs(x))</span>
<span class="line">    ret += (20.0 * math.sin(6.0 * x * math.pi) + </span>
<span class="line">            20.0 * math.sin(2.0 * x * math.pi)) * 2.0 / 3.0</span>
<span class="line">    ret += (20.0 * math.sin(x * math.pi) + </span>
<span class="line">            40.0 * math.sin(x / 3.0 * math.pi)) * 2.0 / 3.0</span>
<span class="line">    ret += (150.0 * math.sin(x / 12.0 * math.pi) + </span>
<span class="line">            300.0 * math.sin(x / 30.0 * math.pi)) * 2.0 / 3.0</span>
<span class="line">    return ret</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"># === Rate Limiter ===</span>
<span class="line"></span>
<span class="line">@dataclass</span>
<span class="line">class TokenBucket:</span>
<span class="line">    rate: float</span>
<span class="line">    capacity: float</span>
<span class="line">    _tokens: float = field(init=False)</span>
<span class="line">    _timestamp: float = field(init=False)</span>
<span class="line">    _lock: threading.Lock = field(init=False)</span>
<span class="line">    </span>
<span class="line">    def __post_init__(self):</span>
<span class="line">        self._tokens = self.capacity</span>
<span class="line">        self._timestamp = time.time()</span>
<span class="line">        self._lock = threading.Lock()</span>
<span class="line">    </span>
<span class="line">    def acquire(self, tokens: int = 1) -&gt; bool:</span>
<span class="line">        with self._lock:</span>
<span class="line">            now = time.time()</span>
<span class="line">            self._tokens = min(</span>
<span class="line">                self.capacity,</span>
<span class="line">                self._tokens + (now - self._timestamp) * self.rate</span>
<span class="line">            )</span>
<span class="line">            self._timestamp = now</span>
<span class="line">            if self._tokens &gt;= tokens:</span>
<span class="line">                self._tokens -= tokens</span>
<span class="line">                return True</span>
<span class="line">            return False</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"># === Main Engine ===</span>
<span class="line"></span>
<span class="line">class SpatialDataEngine:</span>
<span class="line">    </span>
<span class="line">    def __init__(</span>
<span class="line">        self,</span>
<span class="line">        api_key: str,</span>
<span class="line">        pool_size: int = 50,</span>
<span class="line">        qps: float = 100,</span>
<span class="line">        burst: float = 200,</span>
<span class="line">        base_url: str = &quot;https://restapi.amap.com/v3/geocode/geo&quot;,</span>
<span class="line">    ):</span>
<span class="line">        self.api_key = api_key</span>
<span class="line">        self.base_url = base_url</span>
<span class="line">        self._session = self._create_session(pool_size)</span>
<span class="line">        self._limiter = TokenBucket(rate=qps, capacity=burst)</span>
<span class="line">    </span>
<span class="line">    def _create_session(self, pool_size: int) -&gt; requests.Session:</span>
<span class="line">        session = requests.Session()</span>
<span class="line">        retry = Retry(</span>
<span class="line">            total=5,</span>
<span class="line">            backoff_factor=1,</span>
<span class="line">            status_forcelist=[429, 500, 502, 503, 504],</span>
<span class="line">            allowed_methods=[&quot;GET&quot;],</span>
<span class="line">        )</span>
<span class="line">        adapter = HTTPAdapter(</span>
<span class="line">            max_retries=retry,</span>
<span class="line">            pool_connections=pool_size,</span>
<span class="line">            pool_maxsize=pool_size,</span>
<span class="line">        )</span>
<span class="line">        session.mount(&quot;https://&quot;, adapter)</span>
<span class="line">        session.mount(&quot;http://&quot;, adapter)</span>
<span class="line">        return session</span>
<span class="line">    </span>
<span class="line">    def geocode(self, address: str, </span>
<span class="line">                timeout: tuple[float, float] = (3.0, 10.0)) -&gt; dict[str, Any]:</span>
<span class="line">        if not self._limiter.acquire():</span>
<span class="line">            return {&quot;error&quot;: &quot;rate_limited&quot;, &quot;retry_after&quot;: 1.0}</span>
<span class="line">        </span>
<span class="line">        try:</span>
<span class="line">            resp = self._session.get(</span>
<span class="line">                self.base_url,</span>
<span class="line">                params={&quot;address&quot;: address, &quot;key&quot;: self.api_key},</span>
<span class="line">                timeout=timeout,</span>
<span class="line">            )</span>
<span class="line">            resp.raise_for_status()</span>
<span class="line">            return resp.json()</span>
<span class="line">        except requests.exceptions.Timeout:</span>
<span class="line">            return {&quot;error&quot;: &quot;timeout&quot;}</span>
<span class="line">        except requests.exceptions.ConnectionError as e:</span>
<span class="line">            return {&quot;error&quot;: &quot;connection_failed&quot;, &quot;detail&quot;: str(e)}</span>
<span class="line">        except requests.exceptions.HTTPError as e:</span>
<span class="line">            return {&quot;error&quot;: &quot;http_error&quot;, &quot;status&quot;: e.response.status_code}</span>
<span class="line">    </span>
<span class="line">    @staticmethod</span>
<span class="line">    def wgs84_to_gcj02(lng: float, lat: float) -&gt; tuple[float, float]:</span>
<span class="line">        if _out_of_china(lng, lat):</span>
<span class="line">            return lng, lat</span>
<span class="line">        dlat = _transform_lat(lng - 105.0, lat - 35.0)</span>
<span class="line">        dlng = _transform_lng(lng - 105.0, lat - 35.0)</span>
<span class="line">        rad_lat = lat / 180.0 * math.pi</span>
<span class="line">        magic = 1 - _EE * math.sin(rad_lat) ** 2</span>
<span class="line">        sqrt_magic = math.sqrt(magic)</span>
<span class="line">        dlat = (dlat * 180.0) / ((_A * (1 - _EE)) / (magic * sqrt_magic) * math.pi)</span>
<span class="line">        dlng = (dlng * 180.0) / (_A / sqrt_magic * math.cos(rad_lat) * math.pi)</span>
<span class="line">        return lng + dlng, lat + dlat</span>
<span class="line">    </span>
<span class="line">    @staticmethod</span>
<span class="line">    def gcj02_to_wgs84(lng: float, lat: float, </span>
<span class="line">                       tol: float = 1e-6, max_iter: int = 10) -&gt; tuple[float, float]:</span>
<span class="line">        wgs_lng, wgs_lat = lng, lat</span>
<span class="line">        for _ in range(max_iter):</span>
<span class="line">            pred_lng, pred_lat = SpatialDataEngine.wgs84_to_gcj02(wgs_lng, wgs_lat)</span>
<span class="line">            dlng, dlat = pred_lng - lng, pred_lat - lat</span>
<span class="line">            if abs(dlng) &lt; tol and abs(dlat) &lt; tol:</span>
<span class="line">                break</span>
<span class="line">            wgs_lng -= dlng</span>
<span class="line">            wgs_lat -= dlat</span>
<span class="line">        return wgs_lng, wgs_lat</span></code></pre>
<hr>
<h2>Key Takeaways</h2>
<table>
<thead>
<tr>
<th>Layer</th>
<th>Problem</th>
<th>Solution</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Data</strong></td>
<td>Coordinate system mismatch</td>
<td>CRS transformation + iterative inversion</td>
</tr>
<tr>
<td><strong>Network</strong></td>
<td>Connection overhead, transient failures</td>
<td>Persistent pool + exponential backoff</td>
</tr>
<tr>
<td><strong>System</strong></td>
<td>Quota exhaustion</td>
<td>Token bucket rate limiting</td>
</tr>
</tbody></table>
<p>Each layer is invisible until it fails. The code above handles all three.</p>
<hr>
<h2>Next Steps</h2>
<ul>
<li><strong>Multi-provider failover</strong>: Route to backup API on errors</li>
<li><strong>Response caching</strong>: Addresses rarely move; cache aggressively  </li>
<li><strong>Async processing</strong>: Use <code>asyncio</code> + <code>aiohttp</code> for bulk geocoding</li>
<li><strong>Observability</strong>: Export latency, error rates, token utilization to your monitoring stack</li>
</ul>
<p><em>#geocoding #python #distributed-systems #rate-limiting #geospatial #backend-engineering</em></p>

    </article>
    </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
<script>
Prism.highlightAll();
document.querySelectorAll('article pre').forEach(pre => {
    const code = pre.querySelector('code');
    if (!code) return;
    const toolbar = document.createElement('div');
    toolbar.className = 'code-toolbar';
    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = () => {
        navigator.clipboard.writeText(code.textContent).then(() => {
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000);
        });
    };
    toolbar.appendChild(btn);
    pre.parentNode.insertBefore(toolbar, pre);
});
</script>
</body>
</html>