<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>用Python脚本快速实现MCP服务器：Astro博客自动化实践</title>
    <style>
        body { font-family: Georgia, serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; line-height: 1.7; color: #333; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        h2 { font-size: 1.4rem; margin-top: 2rem; }
        pre { background: #f4f4f4; padding: 1rem; overflow-x: auto; border-radius: 4px; }
        code { font-family: Menlo, Monaco, monospace; font-size: 0.9em; }
        p code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; }
        img { max-width: 100%; }
        blockquote { border-left: 3px solid #ddd; margin-left: 0; padding-left: 1rem; color: #666; }
        ul { padding-left: 1.5rem; }
        hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        a { color: #1a8917; }
    </style>
</head>
<body>
<hr>
<h2>date: 2025-07-27
tags: [devops, mcp, python, astro, 自动化, fastmcp]
legacy: true</h2>
<h1>用Python脚本快速实现MCP服务器：Astro博客自动化实践</h1>
<p>在深入代码之前，我们先来认识一下核心库 <code>fastmcp</code>。你可以把它想象成一根魔法棒，只要对着一个普通的Python函数挥舞一下（即使用一个装饰器），这个函数就能立刻被封装成一个符合MCP协议标准的工具，可供AI客户端调用。</p>
<p><code>FastMCP</code> 的设计哲学是&quot;简约而不简单&quot;。它为你处理了所有与MCP协议相关的底层细节，如JSON-RPC通信、工具发现和异步执行。开发者唯一需要做的，就是专注于编写工具函数的业务逻辑。</p>
<p>在我们的脚本中，<code>FastMCP</code> 的使用体现在以下两行核心代码上：</p>
<blockquote><code># 1. 初始化一个MCP应用实例</code><br>
<code>app = FastMCP(</code><br>
<code>    name=&quot;Astro Deployment MCP Server&quot;,</code><br>
<code>    instructions=&quot;Exposes publish_article and commit_code tools for an Astro blog&quot;,</code><br>
<code>)</code><br>
<code></code><br>
<code># 2. 使用 @app.tool() 装饰器将函数注册为工具</code><br>
<code>@app.tool()</code><br>
<code>async def my_tool_function():</code><br>
<code>    # ... tool logic ...</code><br>
<code>    return &quot;Tool execution result&quot;</code></blockquote><p><code>name</code> 和 <code>instructions</code> 字段是元数据，它们会告诉MCP客户端这个服务器的用途和它所提供的能力，非常有助于AI理解上下文。而 <code>@app.tool()</code> 装饰器则是这一切的核心，它自动将任何被其装饰的 <code>async</code> 函数注册为可供远程调用的工具。</p>
<h2>目标：自动化Astro博客的工作流</h2>
<p>我们的目标非常明确：让AI能够独立完成发布一篇新博客文章的完整流程。这个流程可以分解为三个核心动作：</p>
<ol>
<li><strong>保存文章</strong>：将AI生成的Markdown内容保存到Astro项目指定的目录中。</li>
<li><strong>提交代码</strong>：将新添加的文章文件通过Git进行暂存（add）、提交（commit）和推送（push）。</li>
<li><strong>发布网站</strong>：执行部署命令，将最新的博客内容发布到线上服务器。</li>
</ol>
<p>接下来，我们将逐一分析实现这三个动作的工具函数。</p>
<h2>代码实现详解</h2>
<p>我们的MCP服务器是一个独立的Python脚本 <code>astro_mcp_server.py</code>。让我们看看它的构成。</p>
<h3>1. 环境配置与辅助函数</h3>
<p>脚本首先要做的是确定Astro博客项目的根目录。通过读取环境变量 <code>ASTRO_DIR</code>，我们实现了配置的灵活性，同时提供了一个默认值 <code>./astro</code>。这里巧妙地使用了 <code>pathlib</code> 库，它是现代Python中处理文件路径的最佳实践。</p>
<blockquote><code>import os</code><br>
<code>import pathlib</code><br>
<code></code><br>
<code># 配置</code><br>
<code>ASTRO_DIR = pathlib.Path(os.getenv(&quot;ASTRO_DIR&quot;, &quot;./astro&quot;)).expanduser().resolve()</code><br>
<code>if not ASTRO_DIR.is_dir():</code><br>
<code>    raise RuntimeError(</code><br>
<code>        f&quot;ASTRO_DIR {ASTRO_DIR} does not exist or is not a directory&quot;</code><br>
<code>    )</code></blockquote><p>为了避免在每个工具函数中重复编写执行命令行指令的代码，我们定义了一个辅助函数 <code>_run</code>。它使用 <code>subprocess.run</code> 在指定的 <code>ASTRO_DIR</code> 目录中执行命令，并捕获其标准输出和错误流。返回的日志中包含了执行的命令本身，这对于调试和追踪非常有帮助。</p>
<blockquote><code>import subprocess</code><br>
<code>from typing import List</code><br>
<code></code><br>
<code>def _run(cmd: List[str]) -&gt; str:</code><br>
<code>    &quot;&quot;&quot;在ASTRO_DIR中运行命令并返回输出&quot;&quot;&quot;</code><br>
<code>    proc = subprocess.run(cmd, cwd=ASTRO_DIR, capture_output=True, text=True)</code><br>
<code>    banner = f&quot;$ {&#039; &#039;.join(cmd)}\n&quot;</code><br>
<code>    return banner + proc.stdout + proc.stderr</code></blockquote><h3>2. 工具一：<code>save_article</code> - 智能保存文章</h3>
<p>这是最核心的工具之一。它接收目录、文件名和文章内容作为参数，并将其写入文件。</p>
<blockquote><code>@app.tool()</code><br>
<code>async def save_article(directory: str, content: str, filename: str) -&gt; str:</code><br>
<code>    &quot;&quot;&quot;Save article content to a file in the specified directory within ASTRO_DIR.&quot;&quot;&quot;</code><br>
<code>    import datetime</code><br>
<code>    </code><br>
<code>    target_dir = ASTRO_DIR / directory</code><br>
<code>    target_dir.mkdir(parents=True, exist_ok=True)</code><br>
<code>    </code><br>
<code># ... (23 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>这个函数最亮眼的部分是它<strong>智能添加Frontmatter</strong>的逻辑。Frontmatter是静态网站生成器（如Astro, Hugo, Jekyll）用来定义页面元数据（如标题、发布日期）的块。此脚本的逻辑是：</p>
<ol>
<li>检查文件是否为Markdown (<code>.md</code> 或 <code>.mdx</code>)。</li>
<li>检查内容是否已经包含Frontmatter (<code>---</code>)。</li>
<li>如果需要添加，它会智能地推断文章标题：优先使用文件名，但如果文章开头几行内找到了一个H1标题（<code># </code>），则会使用该H1标题。</li>
<li>自动生成包含标题、当前日期、描述和作者的Frontmatter，并将其添加到文章内容的最前面。</li>
</ol>
<p>这个小小的功能极大地提升了AI生成文章的规范性，无需AI客户端操心Frontmatter的格式细节。</p>
<h3>3. 工具二：<code>commit_code</code> - 自动化版本控制</h3>
<p>文章保存后，下一步就是将其纳入版本控制。<code>commit_code</code> 工具封装了标准的Git工作流。</p>
<blockquote><code>@app.tool()</code><br>
<code>async def commit_code(message: str = &quot;chore: automated commit&quot;) -&gt; str:</code><br>
<code>    &quot;&quot;&quot;Stage, commit, and push code changes in ASTRO_DIR.&quot;&quot;&quot;</code><br>
<code>    outputs: List[str] = []</code><br>
<code>    </code><br>
<code>    outputs.append(_run([&quot;git&quot;, &quot;add&quot;, &quot;-A&quot;]))</code><br>
<code>    </code><br>
<code>    commit_result = _run([&quot;git&quot;, &quot;commit&quot;, &quot;-m&quot;, message])</code><br>
<code># ... (8 more lines)</code></blockquote>
<p><em>Full code available in the <a href="https://github.com/geyuxu">GitHub repository</a>.</em></p><p>这个函数按顺序执行 <code>git add -A</code>、<code>git commit</code> 和 <code>git push</code>。它还包含一个实用的检查：只有当 <code>git commit</code> 成功创建了一个新的提交时（即输出中不包含 &quot;nothing to commit&quot;），它才会执行 <code>git push</code>，避免了不必要的推送操作。函数的返回值是所有Git命令的完整输出，便于AI客户端了解每一步的执行情况。</p>
<h3>4. 工具三：<code>publish_article</code> - 一键发布</h3>
<p>这是最简单但也是最终临门一脚的工具。它只做一件事：执行部署命令。</p>
<blockquote><code>@app.tool()</code><br>
<code>async def publish_article() -&gt; str:</code><br>
<code>    &quot;&quot;&quot;Deploy the Astro blog to production by running npm run deploy.&quot;&quot;&quot;</code><br>
<code>    return _run([&quot;npm&quot;, &quot;run&quot;, &quot;deploy&quot;])</code></blockquote><p>该工具假设你的Astro项目 <code>package.json</code> 文件中已经定义了一个名为 <code>deploy</code> 的脚本，该脚本负责处理所有构建和部署到生产环境的逻辑（例如，推送到Vercel、Netlify或你自己的服务器）。这种设计将部署的复杂性与MCP服务器本身解耦，非常灵活。</p>
<h2>如何运行与使用</h2>
<p>现在我们已经拥有了全套工具，如何让它工作起来呢？</p>
<h3>1. 准备工作</h3>
<ul>
<li>确保你的系统安装了Python 3。</li>
<li>安装 <code>fastmcp</code> 库：<code>pip install fastmcp</code>。</li>
<li>准备一个Astro博客项目，并确保它是一个Git仓库。</li>
<li>在Astro项目的 <code>package.json</code> 中，添加一个 <code>deploy</code> 脚本。例如：<blockquote><code>&quot;scripts&quot;: {</code><br>
<code>  &quot;dev&quot;: &quot;astro dev&quot;,</code><br>
<code>  &quot;start&quot;: &quot;astro dev&quot;,</code><br>
<code>  &quot;build&quot;: &quot;astro build&quot;,</code><br>
<code>  &quot;preview&quot;: &quot;astro preview&quot;,</code><br>
<code>  &quot;deploy&quot;: &quot;astro build &amp;&amp; gh-pages -d dist --branch gh-pages&quot;</code><br>
<code>}</code></blockquote></li>
</ul>
<h3>2. 运行MCP服务器</h3>
<ul>
<li>将 <code>astro_mcp_server.py</code> 脚本放置在你的工作区。</li>
<li>在终端中，设置 <code>ASTRO_DIR</code> 环境变量，指向你的博客项目根目录：<p><code>export ASTRO_DIR=&quot;/path/to/your/astro-blog&quot;</code></p></li>
<li>运行脚本：<p><code>python3 astro_mcp_server.py</code></p></li>
</ul>
<p>执行后，脚本不会有任何输出，它会静默地在后台等待来自标准输入的MCP指令。</p>
<h3>3. 与MCP客户端交互</h3>
<p>这个脚本本身是一个&quot;服务器&quot;，它需要一个&quot;客户端&quot;来与之对话。这个客户端通常是AI智能体所在的执行环境。客户端会启动 <code>astro_mcp_server.py</code> 作为一个子进程，然后通过该进程的标准输入（stdin）发送JSON-RPC格式的请求，并从其标准输出（stdout）读取结果。</p>
<p>例如，一个AI客户端想调用 <code>save_article</code> 工具时，可能会向脚本的stdin写入类似下面这样的JSON数据：</p>
<blockquote><code>{</code><br>
<code>  &quot;jsonrpc&quot;: &quot;2.0&quot;, </code><br>
<code>  &quot;method&quot;: &quot;save_article&quot;, </code><br>
<code>  &quot;params&quot;: {</code><br>
<code>    &quot;directory&quot;: &quot;src/content/blog&quot;, </code><br>
<code>    &quot;filename&quot;: &quot;new-ai-article.md&quot;, </code><br>
<code>    &quot;content&quot;: &quot;# A New Beginning\n\nThis is my first article written by AI!&quot;</code><br>
<code>  }, </code><br>
<code>  &quot;id&quot;: 1</code><br>
<code>}</code></blockquote><p>脚本在收到指令后，会执行对应的 <code>save_article</code> 函数，并将执行结果（成功信息或错误）以JSON-RPC响应的格式写回stdout，供客户端解析。</p>
<h2>总结</h2>
<p>我们通过一个不到100行的Python脚本，成功地为Astro博客构建了一个功能强大的自动化MCP服务器。这个案例完美地诠释了&quot;小而美&quot;的工程哲学：</p>
<ul>
<li><strong>简单直接</strong>：纯Python脚本，无复杂的框架或配置。</li>
<li><strong>职责单一</strong>：专注于提供与博客交互的工具，不处理其他无关逻辑。</li>
<li><strong>善用现有工具</strong>：通过 <code>subprocess</code> 巧妙地封装了 <code>git</code> 和 <code>npm</code> 等成熟的命令行工具，而不是在Python中重新发明轮子。</li>
<li><strong>高度可扩展</strong>：需要新功能？只需添加一个新的 <code>@app.tool()</code> 装饰的函数即可。</li>
</ul>
<p>这种模式不仅限于Astro博客，你可以轻松地将其改造，用于自动化任何可以通过命令行或脚本操作的工作流——无论是管理云服务、操作数据库，还是控制本地的物联网设备。MCP和 <code>FastMCP</code> 为我们打开了一扇门，让AI能够更深入、更无缝地融入我们的数字生活和工作中。</p>

</body>
</html>