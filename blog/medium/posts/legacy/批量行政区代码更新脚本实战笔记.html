<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>批量行政区代码更新脚本实战笔记</title>
    <style>
        body { font-family: Georgia, serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; line-height: 1.7; color: #333; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        h2 { font-size: 1.4rem; margin-top: 2rem; }
        pre { background: #f4f4f4; padding: 1rem; overflow-x: auto; border-radius: 4px; }
        code { font-family: Menlo, Monaco, monospace; font-size: 0.9em; }
        p code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; }
        img { max-width: 100%; }
        blockquote { border-left: 3px solid #ddd; margin-left: 0; padding-left: 1rem; color: #666; }
        ul { padding-left: 1.5rem; }
        hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        a { color: #1a8917; }
    </style>
</head>
<body>
<hr>
<h2>date: 2021-10-12
tags: [general_notes]
legacy: true</h2>
<h1>批量行政区代码更新脚本实战笔记</h1>
<h2>脚本生成思路</h2>
<ul>
<li>源数据整理至 CSV：<code>STORE_CODE,STORE_TYPE,OLD_AREA,NEW_AREA</code>。</li>
<li>使用简单 Python 模版批量输出：</li>
</ul>
<blockquote><code>import csv, datetime</code><br>
<code>tpl = &quot;update site_store set area = {new} where store_code = &#039;{code}&#039; and store_type = &#039;{typ}&#039;;&quot;</code><br>
<code>with open(&#039;mapping.csv&#039;) as f, open(&#039;update.sql&#039;,&#039;w&#039;) as out:</code><br>
<code>    for row in csv.DictReader(f):</code><br>
<code>        out.write(tpl.format(**row)+&#039;\n&#039;)</code></blockquote><ul>
<li>模板优势：</li>
<li>可读性强，后期维护仅需修改 CSV。</li>
<li>支持追加其他字段（如 city）而无需改脚本主体。</li>
</ul>
<h2>执行前校验</h2>
<ul>
<li><p>备份：</p>
<ul>
<li>利用 <code>CREATE TABLE site_store_bak AS SELECT * FROM site_store WHERE store_code IN (...)</code> 备份受影响行。</li>
</ul>
</li>
<li><p>常量检查：</p>
<ul>
<li><code>SELECT COUNT(1) FROM site_store_bak</code> 与脚本行数一致。</li>
<li>编码有效性：通过 <code>sys_area</code> 字典表校验 <code>new_area</code> 均存在。</li>
</ul>
</li>
</ul>
<h2>最佳执行姿势</h2>
<ul>
<li>会话设置：</li>
</ul>
<blockquote><code>SET SERVEROUTPUT ON</code><br>
<code>WHENEVER SQLERROR EXIT SQL.SQLCODE</code></blockquote><ul>
<li>使用 <code>@update.sql</code> 执行，遇错即停。</li>
<li>分批提交：<ul>
<li>每 500 条 COMMIT 一次，减少回滚体积。</li>
</ul>
</li>
</ul>
<h2>校验与回滚</h2>
<ul>
<li><p>快速校验：</p>
<ul>
<li><code>SELECT COUNT(*) WHERE area = new_area</code> 验证成功率。</li>
</ul>
</li>
<li><p>聚合对比：<code>SUM(old_area)</code> vs <code>SUM(new_area)</code>。</p>
</li>
<li><p>回滚方案：若发现误更新，使用 <code>MERGE</code> 将备份表写回原表。</p>
</li>
</ul>
<h2>常见坑</h2>
<ul>
<li><strong>行锁争抢</strong>：门店表被其他业务写入，可在夜间窗口操作。</li>
<li><strong>错误编码</strong>：脚本中若写错 <code>WHERE</code> 条件，可能更新全国门店。务必在测试库实测并 <code>EXPLAIN PLAN</code> 确认命中行。</li>
<li><strong>权限问题</strong>：生产执行需 DBA 协助，提前走变更流程。</li>
</ul>
<h2>优化与扩展</h2>
<ul>
<li>改用 <strong>MERGE INTO</strong> 一次完成：</li>
</ul>
<blockquote><code>MERGE INTO site_store s USING tmp_area_map m</code><br>
<code>ON (s.store_code = m.store_code AND s.store_type = m.store_type)</code><br>
<code>WHEN MATCHED THEN UPDATE SET s.area = m.new_area;</code></blockquote><ul>
<li>加 <code>CHECK(area IN (SELECT id FROM sys_area))</code> 防止脏数据。</li>
<li>自动化校验：脚本执行完触发 Jenkins Job，对比异常差异并出报警。</li>
</ul>
<h2>总结</h2>
<ul>
<li>批量数据脚本需求看似简单，核心在于 <strong>生成可靠脚本</strong> + <strong>完善备份校验</strong>。</li>
<li>小型场景用单条 <code>UPDATE</code> 直观易读；大规模可考虑 <code>MERGE</code> 或 ETL 工具。</li>
<li>数据治理应在源头加约束，降低后期修补成本。</li>
</ul>

</body>
</html>