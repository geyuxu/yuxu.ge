<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT + Claude Code 混合开发工作流：一种兼顾规划、敏捷与质量的AI编程新范式 | Yuxu Ge</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --black: #111;
            --dark-grey: #444;
            --off-white: #f4f4f4;
            --vermilion: #C41E3A;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--black);
            background-color: var(--off-white);
        }

        a { color: var(--vermilion); text-decoration: none; }
        a:hover { opacity: 0.75; }

        .layout { min-height: 100vh; }

        /* Sidebar */
        .sidebar {
            position: fixed; top: 0; left: 0;
            width: 320px; height: 100vh;
            background: var(--black); color: var(--off-white);
            padding: 3rem 2rem;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .sidebar-top { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .avatar { display: block; width: 120px; height: 120px; border-radius: 50%; border: 3px solid var(--vermilion); margin-bottom: 1.5rem; overflow: hidden; transition: transform 0.2s ease; }
        .avatar:hover { opacity: 1; transform: scale(1.05); }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .name-block { margin-bottom: 0.5rem; }
        h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: 1px; color: var(--off-white); }
        .title-role { font-size: 0.9rem; color: #888; margin-top: 0.25rem; font-weight: 400; }
        .contact-block { margin-top: 2.5rem; width: 100%; }
        .social-links { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .social-links a { display: flex; align-items: center; gap: 0.75rem; width: 160px; color: var(--off-white); opacity: 0.7; padding: 0.5rem 0.75rem; border-radius: 4px; font-size: 0.9rem; transition: all 0.2s; }
        .social-links a:hover { color: var(--vermilion); opacity: 1; background: rgba(255,255,255,0.05); }
        .social-links svg { width: 20px; height: 20px; flex-shrink: 0; }
        .social-links .orcid-link { font-size: 0.68rem; gap: 0.5rem; white-space: nowrap; }
        .sidebar-footer { text-align: center; font-size: 0.75rem; color: #555; }

        /* Content */
        .content { margin-left: 320px; padding: 3rem 4rem; max-width: 900px; }
        .back-link { display: inline-block; font-size: 0.85rem; margin-bottom: 2rem; color: var(--dark-grey); }
        .back-link:hover { color: var(--vermilion); }

        /* Article */
        article h1 { font-size: 2rem; font-weight: 700; margin-bottom: 1.5rem; line-height: 1.3; color: var(--black); }
        article h2 { font-size: 1.4rem; font-weight: 600; margin: 2rem 0 1rem; color: var(--black); }
        article h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; color: var(--black); }
        article p { margin-bottom: 1rem; color: var(--dark-grey); }
        article ul, article ol { margin: 1rem 0 1rem 1.5rem; color: var(--dark-grey); }
        article li { margin-bottom: 0.5rem; }
        article strong { color: var(--black); }
        article code { font-family: "SF Mono", Monaco, monospace; font-size: 0.9em; background: #e8e8e8; padding: 0.15em 0.4em; border-radius: 3px; }
        article pre { margin: 1rem 0; border-radius: 6px; overflow-x: auto; background: #2d2d2d; padding: 1rem; }
        article pre code { background: none; padding: 0; font-size: 0.75em; white-space: pre !important; counter-reset: line; display: block; color: #ccc; }
        article pre code .line { counter-increment: line; }
        article pre code .line::before { content: counter(line); display: inline-block; width: 2.5em; margin-right: 1em; text-align: right; color: #666; user-select: none; }
        .code-toolbar { display: flex; justify-content: flex-start; padding: 0.35rem 0.5rem; background: #3a3a3a; border-radius: 6px 6px 0 0; }
        .code-toolbar + pre { margin-top: 0; border-radius: 0 0 6px 6px; }
        .copy-btn { padding: 0.2rem 0.5rem; font-size: 0.7rem; background: #555; color: #fff; border: none; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
        .copy-btn:hover, .copy-btn:active { background: #777; }
        .copy-btn.copied { background: #2a2; }
        article blockquote { border-left: 3px solid var(--vermilion); padding-left: 1rem; margin: 1rem 0; color: #666; font-style: italic; }
        article hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        article table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        article th, article td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
        article th { background: #e8e8e8; font-weight: 600; }
        article img { max-width: 100%; height: auto; display: block; margin: 1.5rem 0; border-radius: 6px; }

        .loading { text-align: center; padding: 3rem; color: #888; }
        .error { color: var(--vermilion); }

        /* KaTeX math styles */
        .katex-display { overflow-x: auto; overflow-y: hidden; padding: 0.5rem 0; }
        .katex { font-size: 1.1em; }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { position: relative; width: 100%; height: auto; padding: 2rem 1.5rem 1rem; }
            .social-links { flex-direction: row; flex-wrap: wrap; justify-content: center; }
            .social-links a, .social-links .orcid-link { width: auto; padding: 0.5rem; font-size: 0; gap: 0; }
            .social-links svg { width: 24px; height: 24px; }
            .social-links .hide-mobile { display: none; }
            .sidebar-footer { margin-top: 1rem; }
            .content { margin-left: 0; padding: 2rem 1rem; }
        }
        @media (max-width: 480px) {
            .sidebar { padding: 1.5rem 1rem 1rem; }
            .avatar { width: 80px; height: 80px; }
            h1 { font-size: 1.4rem; }
            article h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="layout">
    <aside class="sidebar" id="sidebar-content"></aside>
    <script src="/components/sidebar.js"></script>

    <main class="content">
        <a href="/blog/" class="back-link">← Back to Blog</a>
        <article>
<hr>
<h2>date: 2025-07-24
tags: [manage]
legacy: true</h2>
<h1>ChatGPT + Claude Code 混合开发工作流：一种兼顾规划、敏捷与质量的AI编程新范式</h1>
<p>经过多次实践与迭代，我摸索出了一套行之有效的 <strong>&quot;ChatGPT + Claude Code 混合开发工作流&quot;</strong>。这套工作流的核心思想是 <strong>&quot;规划与执行分离，人类主导决策&quot;</strong>，它将ChatGPT强大的对话式规划能力与Claude Code卓越的长上下文代码实现能力相结合，同时确保开发者在每一个关键节点都拥有绝对的控制权。</p>
<p>本文将从实践者角度，为你深度解析这套工作流的每一个环节。</p>
<h2>一、 模式核心优势：为什么选择&quot;混合&quot;与&quot;分步&quot;？</h2>
<p>在深入细节之前，我们先来理解这套工作流为何高效且可靠。它主要解决了四个关键问题：</p>
<ol>
<li><strong>规划先行，思路清晰 (Clarity before Code)</strong>：通过与ChatGPT的深度对话生成一份详尽的&quot;开发蓝图&quot;，我们强制自己在编码前就想清楚项目的目标、架构、技术选型和实现路径。这份蓝图是整个项目的&quot;唯一真相来源&quot;，确保了后续开发的方向性和一致性。</li>
<li><strong>迭代可控，敏捷开发 (Controlled Agility)</strong>：我们将宏大的目标拆解成蓝图中一个个具体、可执行的步骤。每一步都在开发者的监督下完成，这天然地形成了一个&quot;编码-审查-确认&quot;的微型敏捷循环。你可以随时检验成果，确保它符合预期，而不是等到最后才发现南辕北辙。</li>
<li><strong>质量内建，步步为营 (Built-in Quality)</strong>：开发者的参与不再是事后补救，而是内建于流程之中。在每一步，你都可以对AI生成的代码进行质量把控、提出优化建议、补充边缘案例测试，甚至基于当前结果调整下一步计划。这种&quot;步步为营&quot;的方式，从根本上杜绝了&quot;黑盒代码&quot;的产生。</li>
<li><strong>优势互补，强强联合 (Synergistic Partnership)</strong>：我们不迷信任何单一模型。ChatGPT更擅长开放式对话、发散性思维和结构化规划；而Claude Code凭借其超长上下文窗口和更稳健的代码生成能力，在具体实现上表现更优。混合工作流正是要让它们在各自最擅长的领域发挥最大价值。</li>
</ol>
<h2>二、 工作流详解：从蓝图到代码的两大阶段</h2>
<p>这套工作流被清晰地划分为两个主要阶段：<strong>蓝图规划阶段</strong> 和 <strong>分步实现阶段</strong>。</p>
<h3>阶段一：与ChatGPT对话，共创项目蓝图 (The Blueprinting Phase)</h3>
<p>这个阶段的目标不是写任何一行代码，而是产出一份高质量的、结构化的项目开发蓝图。</p>
<h4>操作流程：</h4>
<ol>
<li><p><strong>初始播种 (Initial Seeding)</strong>：向ChatGPT发起一个高层次的、开放性的对话。清晰地描述你的项目愿景、核心功能和目标用户。</p>
<blockquote>
<p><strong>提示词示例</strong>：
&quot;你好，我想开发一个个人博客系统。我希望它是一个基于Node.js和Next.js的静态网站，支持Markdown写作，能自动生成标签云和归档页面。请你扮演一位资深技术架构师，和我一起规划这个项目。首先，让我们来明确一下它的核心功能和技术选型。&quot;</p>
</blockquote>
</li>
<li><p><strong>多轮迭代，深化细节 (Iterative Refinement)</strong>：通过追问、提供反馈和注入新想法，与ChatGPT进行多轮对话。这个过程就像与一位真正的架构师进行头脑风暴。</p>
<ul>
<li><strong>追问技术选型</strong>：&quot;为什么推荐Next.js而不是Gatsby？它们在数据获取方面有什么主要区别？&quot;</li>
<li><strong>明确数据结构</strong>：&quot;对于一篇文章，我们需要哪些元数据（metadata）？请帮我设计一个Markdown Frontmatter的格式。&quot;</li>
<li><strong>探讨项目结构</strong>：&quot;请为这个项目设计一个合理的目录结构，并解释每个目录的用途。&quot;</li>
</ul>
</li>
<li><p><strong>收敛成果，生成蓝图 (Generating the Blueprint)</strong>：当所有关键问题都讨论清楚后，要求ChatGPT将所有讨论结果整理成一份结构化的&quot;开发蓝图&quot;。这是本阶段最重要的产出物。</p>
</li>
</ol>
<h4>最佳实践与蓝图模板：</h4>
<ul>
<li><strong>赋予角色</strong>：让ChatGPT扮演特定角色（如&quot;资深架构师&quot;、&quot;产品经理&quot;）能显著提升回答的专业性。</li>
<li><strong>保持对话</strong>：不要试图用一个完美的&quot;超级提示词&quot;一步到位。对话的价值在于迭代和修正。</li>
<li><strong>聚焦&quot;What&quot;和&quot;How&quot;</strong>：蓝图不仅要说明&quot;做什么（What）&quot;，更要明确&quot;怎么做（How）&quot;，即分步实施计划。</li>
</ul>
<hr>
<h4>【模板】项目开发蓝图 (Project Blueprint)</h4>
<p>你可以直接使用以下Markdown模板，要求ChatGPT填充内容。</p>
<pre><code class="language-markdown"><span class="line"># 项目蓝图：[你的项目名称]</span>
<span class="line"></span>
<span class="line">## 1. 项目概述 (Project Overview)</span>
<span class="line">- **一句话描述**: [项目的核心价值主张]</span>
<span class="line">- **目标用户**: [项目为谁服务]</span>
<span class="line">- **核心功能列表**:</span>
<span class="line">  - [功能1: 简要描述]</span>
<span class="line">  - [功能2: 简要描述]</span>
<span class="line">  - ...</span>
<span class="line"></span>
<span class="line">## 2. 技术栈与架构 (Tech Stack &amp; Architecture)</span>
<span class="line">- **前端**: [例如: Next.js 14, React 18, Tailwind CSS]</span>
<span class="line">- **后端/数据层**: [例如: Node.js (用于本地脚本), Gray-matter (解析Markdown), Remark (渲染Markdown)]</span>
<span class="line">- **部署**: [例如: Vercel, Netlify]</span>
<span class="line">- **核心架构决策**: [例如: 采用静态站点生成(SSG)以获得最佳性能和SEO]</span>
<span class="line"></span>
<span class="line">## 3. 数据模型/结构 (Data Models)</span>
<span class="line">- **文章 (Post)**:</span>
<span class="line">  - `title`: string</span>
<span class="line">  - `date`: string (YYYY-MM-DD)</span>
<span class="line">  - `tags`: string[]</span>
<span class="line">  - `slug`: string (URL友好)</span>
<span class="line">  - `content`: string (Markdown内容)</span>
<span class="line"></span>
<span class="line">## 4. 核心目录结构 (Directory Structure)</span></code></pre>
<p>/
├── pages/         # Next.js 页面路由
│   ├── index.js   # 首页
│   └── posts/
│       └── [slug].js # 文章详情页
├── posts/         # 存放 Markdown 源文件
├── components/    # React 组件
├── lib/           # 辅助函数/库代码
└── public/        # 静态资源</p>
<pre><code><span class="line"></span>
<span class="line">## 5. 分步实施计划 (Step-by-Step Implementation Plan)</span>
<span class="line"></span>
<span class="line">**[这是整个工作流的引擎，必须清晰、原子化]**</span>
<span class="line"></span>
<span class="line">- **[步骤 0]**: 初始化项目环境 (Setup Project Environment)</span>
<span class="line">  - 任务: 使用 `create-next-app` 创建项目，安装 `tailwindcss` 并完成基本配置。</span>
<span class="line">- **[步骤 1]**: 实现文章数据读取逻辑 (Implement Post Data Reading Logic)</span>
<span class="line">  - 任务: 在 `lib/posts.js` 中创建一个函数 `getSortedPostsData`，用于读取 `/posts` 目录下所有 `.md` 文件，使用 `gray-matter` 解析元数据，并按日期排序。</span>
<span class="line">- **[步骤 2]**: 创建博客首页 (Build Blog Index Page)</span>
<span class="line">  - 任务: 修改 `pages/index.js`，调用 `getSortedPostsData` 获取所有文章数据，并以列表形式展示文章标题、日期和摘要。</span>
<span class="line">- **[步骤 3]**: 创建文章详情页 (Build Post Detail Page)</span>
<span class="line">  - 任务: 创建 `pages/posts/[slug].js` 动态路由页面。实现 `getStaticPaths` 用于生成所有文章的路径，实现 `getStaticProps` 用于获取特定文章的内容。使用 `remark` 将Markdown内容转换为HTML并渲染。</span>
<span class="line">- **[步骤 N]**: ...</span></code></pre>
<hr>
<h3>阶段二：携手Claude Code，分步编码实现 (The Implementation Phase)</h3>
<p>拿到蓝图后，我们就进入了执行阶段。这里的关键是<strong>严格遵循蓝图，一次只做一个步骤</strong>，并让Claude Code作为我们的&quot;结对编程伙伴&quot;。</p>
<h4>操作流程：</h4>
<ol>
<li><p><strong>提供完整上下文 (Provide Full Context)</strong>：这是成功的关键。在与Claude Code开始第一个实现任务时，将完整的&quot;项目蓝图&quot;作为上下文提供给它。</p>
<blockquote>
<p><strong>提示词示例 (开始步骤1)</strong>：
&quot;你好，我们将基于以下项目蓝图来开发一个博客系统。请仔细阅读整个蓝图。</p>
<pre><code class="language-markdown"><span class="line">[此处粘贴完整的项目蓝图]</span></code></pre>
<p>现在，请帮我完成 <strong>[步骤 1]</strong>: 实现文章数据读取逻辑。
具体任务是：在 <code>lib/posts.js</code> 中创建一个函数 <code>getSortedPostsData</code>，它需要能读取 <code>/posts</code> 目录下所有 <code>.md</code> 文件，使用 <code>gray-matter</code> 解析元数据，并按日期排序后返回。请提供完整的代码，并解释其工作原理。&quot;</p>
</blockquote>
</li>
<li><p><strong>执行、审查、确认 (Execute, Review, Confirm)</strong>：Claude Code会生成代码。此时，你的角色是<strong>代码审查者 (Code Reviewer)</strong>。</p>
<ul>
<li><strong>运行代码</strong>：将代码放入项目中，运行它，看是否符合预期。</li>
<li><strong>审查质量</strong>：代码是否清晰？命名是否规范？有没有潜在的bug？</li>
<li><strong>提供反馈</strong>：如果需要修改，直接向Claude Code提出。例如：&quot;这段代码很好，但请在文件读取部分加入try-catch块来处理异常情况。&quot;</li>
</ul>
</li>
<li><p><strong>迭代推进 (Iterative Advancement)</strong>：当一个步骤完美完成后，带着已完成的代码和原始蓝图，进入下一步。</p>
<blockquote>
<p><strong>提示词示例 (开始步骤2)</strong>：
&quot;很好，步骤1已经完成。<code>lib/posts.js</code> 的代码如下：</p>
<pre><code class="language-javascript"><span class="line">// [此处粘贴上一步已确认的代码]</span></code></pre>
<p>现在，我们来执行蓝图中的 <strong>[步骤 2]</strong>: 创建博客首页。
请修改 <code>pages/index.js</code>，调用我们刚刚创建的 <code>getSortedPostsData</code> 函数，在 <code>getStaticProps</code> 中获取数据，并将文章列表（标题和日期）渲染到页面上。请使用基础的HTML标签，暂时不需要样式。&quot;</p>
</blockquote>
</li>
<li><p><strong>处理分支与变更 (Handling Branches and Changes)</strong>：在开发过程中，你可能会有新的想法，或者发现蓝图需要调整。这是该工作流灵活性的体现。</p>
<ul>
<li><strong>暂停当前任务</strong>：明确地告诉AI：&quot;暂停当前任务，我们有一个变更。&quot;</li>
<li><strong>讨论变更</strong>：像在阶段一一样，与AI（可以是Claude或切回ChatGPT）讨论新想法。</li>
<li><strong>更新蓝图</strong>：将变更记录回你的蓝图文件，并创建一个新的分支步骤，如 <strong>[步骤 3.1]</strong>。</li>
<li><strong>继续执行</strong>：基于更新后的蓝图继续前进。</li>
</ul>
</li>
</ol>
<h2>三、 工具协同分析：ChatGPT vs. Claude Code</h2>
<p>这个工作流的精髓在于精准利用了两个模型的不同优势。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">ChatGPT (GPT-4)</th>
<th align="left">Claude 3 (Opus/Sonnet)</th>
<th align="left">在工作流中的角色</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心优势</strong></td>
<td align="left">对话流畅性、创造性、结构化思维</td>
<td align="left">强大的逻辑推理、代码质量、超长上下文</td>
<td align="left"><strong>规划师 vs. 实现者</strong></td>
</tr>
<tr>
<td align="left"><strong>交互风格</strong></td>
<td align="left">像一个循循善诱的架构师，适合头脑风暴和探索</td>
<td align="left">像一个严谨高效的资深工程师，适合执行明确指令</td>
<td align="left"><strong>发散 vs. 收敛</strong></td>
</tr>
<tr>
<td align="left"><strong>上下文处理</strong></td>
<td align="left">较短，适合分段对话，不适合一次性处理大型代码库</td>
<td align="left">巨大 (200K token)，能轻松&quot;记住&quot;整个项目蓝图和已有代码</td>
<td align="left"><strong>短期记忆 vs. 长期记忆</strong></td>
</tr>
<tr>
<td align="left"><strong>代码质量</strong></td>
<td align="left">倾向于提供&quot;教学式&quot;的代码片段，有时不够健壮</td>
<td align="left">生成的代码更接近生产标准，考虑更多边缘情况</td>
<td align="left"><strong>原型代码 vs. 生产级代码</strong></td>
</tr>
<tr>
<td align="left"><strong>最佳用途</strong></td>
<td align="left">需求分析、技术选型、架构设计、撰写文档和计划</td>
<td align="left">编写具体代码、重构、调试、根据复杂指令生成文件</td>
<td align="left"><strong>制定蓝图 vs. 建造大楼</strong></td>
</tr>
</tbody></table>
<h2>四、 与传统及纯AI开发模式的对比</h2>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">规划阶段</th>
<th align="left">实现阶段</th>
<th align="left">开发者角色</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>传统开发</strong></td>
<td align="left">手动，耗时</td>
<td align="left">手动，耗时</td>
<td align="left">创造者、实现者</td>
<td align="left">完全控制，质量有保障</td>
<td align="left">速度慢，重复劳动多</td>
</tr>
<tr>
<td align="left"><strong>纯AI开发</strong></td>
<td align="left">模糊，AI主导</td>
<td align="left">黑盒，AI主导</td>
<td align="left">审查者、调试者</td>
<td align="left">速度极快（理想情况）</td>
<td align="left">失控，质量不可靠，难以维护</td>
</tr>
<tr>
<td align="left"><strong>混合工作流</strong></td>
<td align="left"><strong>AI辅助，人主导</strong></td>
<td align="left"><strong>AI辅助，人主导</strong></td>
<td align="left"><strong>架构师、指挥官</strong></td>
<td align="left"><strong>速度快、质量高、可控性强</strong></td>
<td align="left">需要开发者具备驾驭AI的能力</td>
</tr>
</tbody></table>
<p>如上表所示，混合工作流并非简单地用AI替代人力，而是将开发者提升到了一个更高的维度——从&quot;敲代码的工人&quot;转变为&quot;指挥AI军团的将军&quot;。你负责制定战略（蓝图），并监督每一场战役（分步实现），从而在享受AI带来的效率提升的同时，牢牢把握项目的最终质量和方向。</p>
<h2>五、 结论：迈向结构化的AI辅助开发</h2>
<p>&quot;ChatGPT + Claude Code 混合开发工作流&quot;为我们提供了一条在AI时代进行高效、高质量软件开发的清晰路径。它告别了混乱的、不可预测的&quot;AI魔法&quot;，引入了工程化的、结构化的协作范式。</p>
<p>通过 <strong>&quot;蓝图驱动&quot;</strong>，我们确保了方向的正确性；通过 <strong>&quot;分步执行&quot;</strong>，我们保证了过程的可控性；通过 <strong>&quot;人类确认&quot;</strong>，我们守护了最终的质量。</p>
<p>这不仅仅是一种技术或技巧，更是一种项目管理的思想。它要求开发者转变角色，从单纯的编码者，进化为能够与AI高效协作的&quot;项目指挥官&quot;。随着AI工具的不断进化，这种人机协同、结构化的开发模式，必将成为未来软件工程的主流。</p>
<p>现在，打开你的编辑器和AI对话框，开始构建你的第一个&quot;AI协作蓝图&quot;吧。</p>

    </article>
    </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
<script>
Prism.highlightAll();
document.querySelectorAll('article pre').forEach(pre => {
    const code = pre.querySelector('code');
    if (!code) return;
    const toolbar = document.createElement('div');
    toolbar.className = 'code-toolbar';
    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = () => {
        navigator.clipboard.writeText(code.textContent).then(() => {
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000);
        });
    };
    toolbar.appendChild(btn);
    pre.parentNode.insertBefore(toolbar, pre);
});
</script>
</body>
</html>