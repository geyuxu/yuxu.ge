<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>结合 Claude Code、Graphiti 和 Neo4j 构建 Agent 长记忆系统 | Yuxu Ge</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --black: #111;
            --dark-grey: #444;
            --off-white: #f4f4f4;
            --vermilion: #C41E3A;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--black);
            background-color: var(--off-white);
        }

        a { color: var(--vermilion); text-decoration: none; }
        a:hover { opacity: 0.75; }

        .layout { min-height: 100vh; }

        /* Sidebar */
        .sidebar {
            position: fixed; top: 0; left: 0;
            width: 320px; height: 100vh;
            background: var(--black); color: var(--off-white);
            padding: 3rem 2rem;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .sidebar-top { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .avatar { display: block; width: 120px; height: 120px; border-radius: 50%; border: 3px solid var(--vermilion); margin-bottom: 1.5rem; overflow: hidden; transition: transform 0.2s ease; }
        .avatar:hover { opacity: 1; transform: scale(1.05); }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .name-block { margin-bottom: 0.5rem; }
        h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: 1px; color: var(--off-white); }
        .title-role { font-size: 0.9rem; color: #888; margin-top: 0.25rem; font-weight: 400; }
        .contact-block { margin-top: 2.5rem; width: 100%; }
        .social-links { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .social-links a { display: flex; align-items: center; gap: 0.75rem; width: 160px; color: var(--off-white); opacity: 0.7; padding: 0.5rem 0.75rem; border-radius: 4px; font-size: 0.9rem; transition: all 0.2s; }
        .social-links a:hover { color: var(--vermilion); opacity: 1; background: rgba(255,255,255,0.05); }
        .social-links svg { width: 20px; height: 20px; flex-shrink: 0; }
        .social-links .orcid-link { font-size: 0.68rem; gap: 0.5rem; white-space: nowrap; }
        .sidebar-footer { text-align: center; font-size: 0.75rem; color: #555; }

        /* Content */
        .content { margin-left: 320px; padding: 3rem 4rem; max-width: 900px; }
        .back-link { display: inline-block; font-size: 0.85rem; margin-bottom: 2rem; color: var(--dark-grey); }
        .back-link:hover { color: var(--vermilion); }

        /* Article */
        article h1 { font-size: 2rem; font-weight: 700; margin-bottom: 1.5rem; line-height: 1.3; color: var(--black); }
        article h2 { font-size: 1.4rem; font-weight: 600; margin: 2rem 0 1rem; color: var(--black); }
        article h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; color: var(--black); }
        article p { margin-bottom: 1rem; color: var(--dark-grey); }
        article ul, article ol { margin: 1rem 0 1rem 1.5rem; color: var(--dark-grey); }
        article li { margin-bottom: 0.5rem; }
        article strong { color: var(--black); }
        article code { font-family: "SF Mono", Monaco, monospace; font-size: 0.9em; background: #e8e8e8; padding: 0.15em 0.4em; border-radius: 3px; }
        article pre { margin: 1rem 0; border-radius: 6px; overflow-x: auto; background: #2d2d2d; padding: 1rem; }
        article pre code { background: none; padding: 0; font-size: 0.75em; white-space: pre !important; counter-reset: line; display: block; color: #ccc; }
        article pre code .line { counter-increment: line; }
        article pre code .line::before { content: counter(line); display: inline-block; width: 2.5em; margin-right: 1em; text-align: right; color: #666; user-select: none; }
        .code-toolbar { display: flex; justify-content: flex-start; padding: 0.35rem 0.5rem; background: #3a3a3a; border-radius: 6px 6px 0 0; }
        .code-toolbar + pre { margin-top: 0; border-radius: 0 0 6px 6px; }
        .copy-btn { padding: 0.2rem 0.5rem; font-size: 0.7rem; background: #555; color: #fff; border: none; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
        .copy-btn:hover, .copy-btn:active { background: #777; }
        .copy-btn.copied { background: #2a2; }
        article blockquote { border-left: 3px solid var(--vermilion); padding-left: 1rem; margin: 1rem 0; color: #666; font-style: italic; }
        article hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        article table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        article th, article td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
        article th { background: #e8e8e8; font-weight: 600; }
        article img { max-width: 100%; height: auto; display: block; margin: 1.5rem 0; border-radius: 6px; }

        .loading { text-align: center; padding: 3rem; color: #888; }
        .error { color: var(--vermilion); }

        /* KaTeX math styles */
        .katex-display { overflow-x: auto; overflow-y: hidden; padding: 0.5rem 0; }
        .katex { font-size: 1.1em; }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { position: relative; width: 100%; height: auto; padding: 2rem 1.5rem 1rem; }
            .social-links { flex-direction: row; flex-wrap: wrap; justify-content: center; }
            .social-links a, .social-links .orcid-link { width: auto; padding: 0.5rem; font-size: 0; gap: 0; }
            .social-links svg { width: 24px; height: 24px; }
            .social-links .hide-mobile { display: none; }
            .sidebar-footer { margin-top: 1rem; }
            .content { margin-left: 0; padding: 2rem 1rem; }
        }
        @media (max-width: 480px) {
            .sidebar { padding: 1.5rem 1rem 1rem; }
            .avatar { width: 80px; height: 80px; }
            h1 { font-size: 1.4rem; }
            article h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="layout">
    <aside class="sidebar" id="sidebar-content"></aside>
    <script src="/components/sidebar.js"></script>

    <main class="content">
        <a href="/blog/" class="back-link">← Back to Blog</a>
        <article>
<hr>
<h2>date: 2025-07-23
tags: [ai]
legacy: true</h2>
<h1>结合 Claude Code、Graphiti 和 Neo4j 构建 Agent 长记忆系统</h1>
<p>下面总结基于实践的安装与配置流程：
1.	安装 Neo4j Desktop：从 Neo4j 官方网站下载 Neo4j Desktop 并安装。Neo4j Desktop 提供直观的界面来管理本地数据库，非常适合入门 。安装完成后启动 Neo4j Desktop。
2.	创建数据库实例并设置密码：在 Neo4j Desktop 中创建一个新的本地图数据库（版本需 5.x 或更高）。首次启动数据库时会要求设置一个密码，请设定Neo4j 用户（默认用户名为 neo4j）的密码，并牢记此信息。默认情况下，Neo4j 的 Bolt 连接 URI 为 bolt://localhost:7687，后续 Graphiti 将通过此 URI 连接数据库。
3.	克隆 Graphiti 仓库并配置环境：打开终端，克隆 Graphiti 源码仓库并进入目录：</p>
<pre><code><span class="line">git clone https://github.com/getzep/graphiti.git</span>
<span class="line">cd graphiti/mcp_server</span></code></pre>
<p>仓库中提供了 .env.example 模板文件。复制一份作为 .env 并根据实际情况填写Neo4j和OpenAI配置：</p>
<pre><code><span class="line">OPENAI_API_KEY=&lt;你的OpenAI API密钥&gt;</span>
<span class="line">MODEL_NAME=gpt-4.1-mini        # 指定LLM模型名称，例如 OpenAI 的 GPT-4 mini 版本</span>
<span class="line">NEO4J_URI=bolt://localhost:7687</span>
<span class="line">NEO4J_USER=neo4j</span>
<span class="line">NEO4J_PASSWORD=&lt;你的Neo4j密码&gt;</span></code></pre>
<p>其中 OPENAI_API_KEY 是 Graphiti 用于调用 OpenAI 接口进行LLM推理和嵌入的密钥，MODEL_NAME 可以指定OpenAI模型（如 gpt-3.5-turbo 或 gpt-4 系列，默认示例使用的是 GPT-4.1 mini 模型），Neo4j 部分填写刚才创建数据库的连接信息和凭证。</p>
<ol start="4">
<li>   安装所需工具（uv、uvicorn、claude-cli）：</li>
</ol>
<ul>
<li>uv：Graphiti 推荐使用 Astral 开发的 uv 工具来管理Python环境和依赖。先通过 pip install uv 安装 uv 。然后在 graphiti/mcp_server 目录下执行 uv sync，该命令会根据项目的锁定文件安装所需的Python包。uv 类似于 pip，但能更快速地同步依赖。若不使用 uv，也可以手动创建虚拟环境并使用 pip install -r requirements.txt 安装依赖。</li>
<li>uvicorn：如果打算通过 HTTP SSE 方式运行服务，需要安装 ASGI 服务器 uvicorn（通常已在依赖中）。确保命令行下可以调用 uvicorn（例如 pip install uvicorn）。</li>
<li>claude-cli：Claude Code 提供了命令行工具来管理 MCP 插件。安装 claude CLI 工具（例如通过 pip install anthropic 或其他途径，具体可参考 Anthropic 文档）。安装后，命令行应能使用 claude 命令，用于添加MCP服务器等配置 。</li>
</ul>
<ol start="5">
<li>   启动 Graphiti MCP Server 并在 Claude 中注册插件：Graphiti 仓库自带 MCP Server 实现，用于充当 Claude 等前端与 Graphiti 后端之间的桥梁。启动步骤有两种方式：</li>
</ol>
<ul>
<li>方法A：通过 Claude Code CLI 启动（stdio 模式）：这种方式将 Graphiti MCP Server 作为 Claude 的子进程，通过标准输入输出通信。在命令行执行以下命令将 Graphiti 插件添加到 Claude Code（user范围）：</li>
</ul>
<pre><code><span class="line">claude mcp add-json graphiti-memory &#39;{</span>
<span class="line">  &quot;type&quot;: &quot;stdio&quot;,</span>
<span class="line">  &quot;command&quot;: &quot;/usr/local/bin/uv&quot;,</span>
<span class="line">  &quot;args&quot;: [</span>
<span class="line">    &quot;run&quot;, &quot;--directory&quot;, &quot;/path/to/graphiti/mcp_server&quot;, </span>
<span class="line">    &quot;graphiti_mcp_server.py&quot;, &quot;--transport&quot;, &quot;stdio&quot;</span>
<span class="line">  ],</span>
<span class="line">  &quot;env&quot;: {</span>
<span class="line">    &quot;OPENAI_API_KEY&quot;: &quot;&lt;你的OpenAI密钥&gt;&quot;,</span>
<span class="line">    &quot;MODEL_NAME&quot;: &quot;gpt-4.1-mini&quot;,</span>
<span class="line">    &quot;NEO4J_URI&quot;: &quot;bolt://localhost:7687&quot;,</span>
<span class="line">    &quot;NEO4J_USER&quot;: &quot;neo4j&quot;,</span>
<span class="line">    &quot;NEO4J_PASSWORD&quot;: &quot;&lt;你的Neo4j密码&gt;&quot;</span>
<span class="line">  }</span>
<span class="line">}&#39;</span></code></pre>
<p>将上述命令中的路径和参数替换为实际值（例如 uv 可执行路径、Graphiti 仓库位置等）。执行后，Claude Code 会登记一个名为 “graphiti-memory” 的 MCP 插件，Claude 在对话中需要用到记忆时会自动启动该Server并通过 stdio 通信。</p>
<ul>
<li>方法B：独立运行 Graphiti Server（SSE 模式）：这种方式下 Graphiti 作为独立服务，通过 HTTP Server-Sent Events (SSE) 接口供 Claude 访问。可以执行：</li>
</ul>
<pre><code><span class="line">cd graphiti/mcp_server</span>
<span class="line">uv run graphiti_mcp_server.py --transport sse --model gpt-4.1-mini</span></code></pre>
<p>上述命令将 Graphiti MCP Server 以 SSE 模式跑在本地（默认监听 0.0.0.0:8000）。成功启动后，使用 Claude CLI 将此服务添加为 MCP 插件：</p>
<pre><code><span class="line">claude mcp add --transport sse --scope user graphiti-memory http://localhost:8000/sse</span></code></pre>
<p>这样Claude就注册了一个名为 “graphiti-memory” 的远程MCP服务（通过HTTP连接）。--scope user 表示对此用户全局可用（也可用 --scope project 针对某项目）。完成后，可在 Claude Code 界面的“MCP Servers”列表中看到 graphiti-memory 插件。</p>
<p>完成以上安装配置后，Claude Agent 就拥有了 Graphiti 知识图谱作为长时记忆存储。接下来可以尝试与 Claude 进行对话，记录信息并验证内存功能。</p>
<h2>使用验证</h2>
<p>要确认 Graphiti 内存是否正常工作，可以从Neo4j侧直接检查数据是否写入：</p>
<ul>
<li>知识图谱节点检查：打开 Neo4j Browser（Neo4j Desktop 内置）连接到刚才的数据库，执行 Cypher 查询：MATCH (n:Episodic) RETURN n LIMIT 25; 。Graphiti 将每条对话或信息片段存储为 “Episodic” 标签的节点，可通过该查询查看最新写入的若干 Episode 节点及其属性。如果能看到节点列表，说明 Claude 已成功将对话内容存进 Neo4j。</li>
</ul>
<p>如果未能查询到任何 Episode 节点或 Graphiti 功能异常，建议从以下方面排查：</p>
<ul>
<li>Bolt 连接问题：确认 Graphiti MCP Server 能连接上 Neo4j 数据库。检查 .env 配置的 NEO4J_URI 和端口是否正确，本地默认应为 bolt://localhost:7687。确保 Neo4j 数据库已启动且未设置防火墙阻止本地 Bolt 连接。如果 Neo4j 使用了非默认的数据库名称或用户名，也需要相应调整 Graphiti 配置。</li>
<li>OpenAI API Key 状态：Graphiti 在写入对话时，会调用 OpenAI 的模型来抽取实体和生成 embeddings 。如果提供的 API Key 无效或者余额不足，Graphiti 可能无法完成 Episode 的解析写入。可以查看运行 Graphiti Server 的终端输出日志，若出现 OpenAI 接口报错或余额不足的信息，则需要更换有效的 API Key（OpenAI 如开启数据分享可每日获得一定免费额度）或者确保账户有足够额度。</li>
<li>Claude 插件启用：确认 Graphiti MCP 插件已在 Claude 前端启用。在 Claude Code 中，新添加的 MCP Server 可能需要在对话界面中开启（如Claude Desktop中需要在对话窗口右上角“插件”列表里勾选启用）。如果插件未启用，Claude将不会实际调用 Graphiti。另请注意，Claude 对资源和提示类型的 MCP 功能默认不会自动触发调用 （详见下文），因此在测试时可以先提出与已记录内容相关的问题，看看 Claude 是否能够利用之前存储的记忆进行回答。</li>
</ul>
<h2>Graphiti Memory 的功能类别</h2>
<p>作为 MCP Server，Graphiti 提供了三类接口能力，对应 MCP 定义的Resources、Tools 和 Prompts 三种类型 。理解这三者有助于发挥 Graphiti 内存的作用：
1.	Resources（资源工具）：用于检索信息的接口。如从内部知识图谱或外部数据库获取内容。这类接口只读数据不产生副作用，作用是让 LLM 访问知识库中的历史信息。例如 Graphiti 提供检索节点、事实的资源接口，支持时间感知的查询，可以按时间或条件获取过往对话片段 。Claude 在需要引用记忆时，可以调用 Resource 类型的功能读取相关内容。
2.	Tools（工具）：用于执行操作的接口，会对外部环境或数据产生变化。如通过 API 写入数据、进行计算等。Graphiti 的工具接口允许 LLM 将新的知识添加到图谱，或调用实时的搜索和图操作，实现在线更新记忆 。每当用户提供新信息，Claude Agent 可以调用 Graphiti 的工具类方法（如 add_episode）将其存为新节点，从而持续积累知识。
3.	Prompts（提示模板）：指预定义的提示词模板或工作流，方便 LLM 和 MCP Server 之间复用复杂交互逻辑。例如 Graphiti 可能提供某些查询的模板，封装常用的多步操作 。这些 Prompt 模板可以视作Agent的一些“技能脚本”，当触发特定需求时调用。通过 Prompts，开发者可将标准查询模式固化，让 Claude 在需要时一键生成对 Graphiti 的查询请求。</p>
<p>需要注意，在 Claude Desktop 目前的实现中，Tools 类型的 MCP 接口（如Graphiti的写入/搜索功能）可以根据对话上下文自动调用，而 Resources 和 Prompts 类型则不会自动触发 。也就是说，即使 Graphiti 列出了可用的资源和提示模板，Claude 默认不知道何时用它们，除非用户主动附加。这一点在实际使用中尤为重要，下一节会讨论应对策略。</p>
<h2>使用建议与踩坑记录</h2>
<p>基于实际体验，这里总结一些使用Graphiti长记忆过程中值得注意的建议和可能遇到的坑：</p>
<ul>
<li>调试 Graphiti 写入：当发现对话内容没有写入Neo4j时，可以检查 Graphiti MCP Server 的控制台输出日志。Graphiti 启动时会打印使用的模型名、Group ID等信息，执行写入时如发生错误（例如 OpenAI 返回格式不符合预期），通常也会有异常堆栈打印在日志中。调试时，可尝试直接调用 Graphiti 的 API（例如 REST 接口）添加测试数据，或使用简短且结构清晰的输入触发 add_episode，以隔离问题。确保 .env 已正确加载（可以在启动命令中显式指定 --env-file .env 以防万一）。如果 Graphiti 提示embedding或解析schema错误，通常是模型输出不符合预期 JSON 格式导致的。</li>
<li>避免 Schema 错误：Graphiti 要求所使用的 LLM 支持结构化输出，以确保提取实体关系时格式正确 。建议使用 OpenAI 的 GPT-4 或新版 GPT-3.5 等具备函数调用或严格JSON输出能力的模型。如果使用不支持结构化输出的模型（尤其是体量较小的模型），可能出现 Graphiti 无法解析返回内容、Episode 写入失败的情况（表现为日志报错 schema mismatch 等）。另外，第一次运行 Graphiti 会在 Neo4j 上创建所需索引和约束，如看到 IndexAlreadyExists 提示可忽略 。在调整 Graphiti 的实体/关系类型定义时，尽量保持与Neo4j模式一致，避免因为模式不符导致写入错误。</li>
<li>Claude 中正确触发 Memory：为了让 Claude 充分利用 Graphiti 长期记忆，需要在对话策略上进行一些引导。目前Claude对 Resource/Prompt 并非自动使用，因此用户或开发者需要主动触发。有几种实践技巧：其一，在对话最开始就提示Claude可以使用Graphiti记忆，并在需要时应先查询图谱。例如可以设定系统提示：“请先搜索已有知识再回答”。其二，熟练运用 Claude 界面提供的**“引用 (References)”** 功能：在 Claude Desktop 中，可点击“+”号从 MCP Server 附加存储的记忆片段作为参考资料 。其三，参考官方建议制定对话约定——例如 “先检索后回答” 和 “有新信息立即记录”。   上述规则可作为Claude的提示，让模型养成遇到新偏好/事实就调用 add_episode 保存，遇到问题先调用 search_nodes/search_facts 检索相关节点和关系的习惯。这种显式的提示能大大提高 Graphiti 内存的利用率。总之，目前需要一定人为引导，未来版本Claude可能会让AI自动意识到可用的记忆资源并调用。</li>
</ul>
<p>通过以上工具链的稳定配置和调整，Claude Code 与 Graphiti + Neo4j 的集成可以顺利运行，一个具备长时记忆的 AI Agent 也就搭建完成了。在真实开发中，我们应不断根据日志和对话表现去优化提示策略，确保AI既“记得住”用户提供的知识，又能在需要时准确想起并加以利用。这套方案在复杂项目中能有效避免信息遗忘，大幅提升Agent长程任务的连贯性和智能水平。今后若Claude插件机制升级，实现自动利用Resource/Prompt，那么AI长记忆将更加得心应手。希望以上踩坑心得能帮助大家更容易地复现这一强大的长记忆Agent方案！</p>

    </article>
    </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
<script>
Prism.highlightAll();
document.querySelectorAll('article pre').forEach(pre => {
    const code = pre.querySelector('code');
    if (!code) return;
    const toolbar = document.createElement('div');
    toolbar.className = 'code-toolbar';
    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = () => {
        navigator.clipboard.writeText(code.textContent).then(() => {
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000);
        });
    };
    toolbar.appendChild(btn);
    pre.parentNode.insertBefore(toolbar, pre);
});
</script>
</body>
</html>