<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog | Yuxu Ge</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --black: #111;
            --dark-grey: #444;
            --off-white: #f4f4f4;
            --vermilion: #C41E3A;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--black);
            background-color: var(--off-white);
        }

        a {
            color: var(--vermilion);
            text-decoration: none;
        }

        a:hover {
            opacity: 0.75;
        }

        .layout {
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 320px;
            height: 100vh;
            background: var(--black);
            color: var(--off-white);
            padding: 3rem 2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .sidebar-top {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .avatar {
            display: block;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px solid var(--vermilion);
            margin-bottom: 1.5rem;
            overflow: hidden;
            transition: transform 0.2s ease;
        }

        .avatar:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .name-block {
            margin-bottom: 0.5rem;
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: 1px;
            color: var(--off-white);
        }

        .title-role {
            font-size: 0.9rem;
            color: #888;
            margin-top: 0.25rem;
            font-weight: 400;
        }

        .contact-block {
            margin-top: 2.5rem;
            width: 100%;
        }

        .social-links {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

        .social-links a {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 160px;
            color: var(--off-white);
            opacity: 0.7;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .social-links a:hover {
            color: var(--vermilion);
            opacity: 1;
            background: rgba(255, 255, 255, 0.05);
        }

        .social-links svg {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .social-links .orcid-link {
            font-size: 0.68rem;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .sidebar-footer {
            text-align: center;
            font-size: 0.75rem;
            color: #555;
        }

        /* Content */
        .content {
            margin-left: 320px;
            padding: 3rem 4rem;
            max-width: 900px;
        }

        .back-link {
            display: inline-block;
            font-size: 0.85rem;
            margin-bottom: 2rem;
            color: var(--dark-grey);
        }

        .back-link:hover {
            color: var(--vermilion);
        }

        /* Article */
        article h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            line-height: 1.3;
            color: var(--black);
        }

        article h2 {
            font-size: 1.4rem;
            font-weight: 600;
            margin: 2rem 0 1rem;
            color: var(--black);
        }

        article h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 1.5rem 0 0.75rem;
            color: var(--black);
        }

        article p {
            margin-bottom: 1rem;
            color: var(--dark-grey);
        }

        article ul,
        article ol {
            margin: 1rem 0 1rem 1.5rem;
            color: var(--dark-grey);
        }

        article li {
            margin-bottom: 0.5rem;
        }

        article strong {
            color: var(--black);
        }

        article code {
            font-family: "SF Mono", Monaco, monospace;
            font-size: 0.9em;
            background: #e8e8e8;
            padding: 0.15em 0.4em;
            border-radius: 3px;
        }

        article pre {
            margin: 1rem 0;
            border-radius: 6px;
            overflow-x: auto;
            background: #2d2d2d;
            padding: 1rem;
        }

        article pre code {
            background: none;
            padding: 0;
            font-size: 0.75em;
            white-space: pre !important;
            counter-reset: line;
            display: block;
            color: #ccc;
        }

        article pre code .line {
            counter-increment: line;
        }

        article pre code .line::before {
            content: counter(line);
            display: inline-block;
            width: 2.5em;
            margin-right: 1em;
            text-align: right;
            color: #666;
            user-select: none;
        }

        .code-toolbar {
            display: flex;
            justify-content: flex-start;
            padding: 0.35rem 0.5rem;
            background: #3a3a3a;
            border-radius: 6px 6px 0 0;
        }

        .code-toolbar+pre {
            margin-top: 0;
            border-radius: 0 0 6px 6px;
        }

        .copy-btn {
            padding: 0.2rem 0.5rem;
            font-size: 0.7rem;
            background: #555;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-btn:hover,
        .copy-btn:active {
            background: #777;
        }

        .copy-btn.copied {
            background: #2a2;
        }

        article blockquote {
            border-left: 3px solid var(--vermilion);
            padding-left: 1rem;
            margin: 1rem 0;
            color: #666;
            font-style: italic;
        }

        article hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 2rem 0;
        }

        article table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        article th,
        article td {
            border: 1px solid #ddd;
            padding: 0.5rem 0.75rem;
            text-align: left;
        }

        article th {
            background: #e8e8e8;
            font-weight: 600;
        }

        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1.5rem 0;
            border-radius: 6px;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: #888;
        }

        .error {
            color: var(--vermilion);
        }

        /* Language Selector */
        .lang-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding: 0.75rem 1rem;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .lang-selector-label {
            color: #666;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .lang-selector-label svg {
            width: 16px;
            height: 16px;
        }

        .lang-select {
            padding: 0.4rem 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 0.85rem;
            cursor: pointer;
            min-width: 140px;
        }

        .lang-select:focus {
            outline: none;
            border-color: var(--vermilion);
        }

        .lang-status {
            font-size: 0.8rem;
            color: #888;
            margin-left: auto;
        }

        .lang-status.translating {
            color: var(--vermilion);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .lang-status.translating::before {
            content: '';
            width: 14px;
            height: 14px;
            border: 2px solid #f0f0f0;
            border-top-color: var(--vermilion);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .lang-status.cached {
            color: #4CAF50;
        }

        .lang-original-btn {
            padding: 0.35rem 0.6rem;
            font-size: 0.75rem;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            color: #666;
            transition: all 0.2s;
        }

        .lang-original-btn:hover {
            background: #e0e0e0;
            color: #333;
        }

        @media (max-width: 600px) {
            .lang-selector {
                flex-wrap: wrap;
            }
            .lang-status {
                width: 100%;
                margin-left: 0;
                margin-top: 0.5rem;
            }
        }

        /* KaTeX math styles */
        .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            padding: 0.5rem 0;
        }

        .katex {
            font-size: 1.1em;
        }

        /* Jupyter Notebook Styles */
        .notebook-container {
            margin-top: 1rem;
        }

        .notebook-download {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            margin-bottom: 1.5rem;
            background: var(--black);
            color: var(--off-white);
            border-radius: 4px;
            font-size: 0.85rem;
            transition: opacity 0.2s;
        }

        .notebook-download:hover {
            opacity: 0.8;
            color: var(--off-white);
        }

        .notebook-download svg {
            width: 16px;
            height: 16px;
        }

        .nb-cell {
            margin-bottom: 1.5rem;
        }

        .nb-cell-code .nb-source {
            background: #2d2d2d;
            border-radius: 6px;
            overflow-x: auto;
        }

        .nb-cell-code .nb-source pre {
            margin: 0;
            padding: 1rem;
            color: #ccc;
            font-family: "SF Mono", Monaco, monospace;
            font-size: 0.85em;
        }

        .nb-cell-code .nb-source code {
            background: none;
            padding: 0;
        }

        .nb-output {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 0.5rem;
        }

        .nb-output pre {
            margin: 0;
            padding: 0;
            background: transparent;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: "SF Mono", Monaco, monospace;
            font-size: 0.85em;
            color: #222;
        }

        .nb-output img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0.5rem 0;
        }

        .nb-output table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .nb-output th,
        .nb-output td {
            border: 1px solid #ddd;
            padding: 0.5rem;
            text-align: left;
        }

        .nb-output th {
            background: #e8e8e8;
            font-weight: 600;
        }

        .nb-cell-markdown {
            padding: 0;
        }

        .nb-cell-markdown h1:first-child {
            margin-top: 0;
        }

        /* Document Download Button */
        .doc-download {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            margin-bottom: 1.5rem;
            background: var(--black);
            color: var(--off-white);
            border-radius: 4px;
            font-size: 0.85rem;
            transition: opacity 0.2s;
        }

        .doc-download:hover {
            opacity: 0.8;
            color: var(--off-white);
        }

        .doc-download svg {
            width: 16px;
            height: 16px;
        }

        /* PDF Viewer */
        .pdf-container {
            margin-top: 1rem;
        }

        .pdf-viewer {
            width: 100%;
            height: 80vh;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #f5f5f5;
        }

        /* Text File Display */
        .text-container {
            margin-top: 1rem;
        }

        .text-content {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 1.5rem;
            font-family: "SF Mono", Monaco, monospace;
            font-size: 0.9em;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: var(--dark-grey);
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Word Document Display */
        .word-container {
            margin-top: 1rem;
        }

        .word-content {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 2rem;
            line-height: 1.8;
            color: var(--dark-grey);
        }

        .word-content p {
            margin-bottom: 1rem;
        }

        .word-content h1,
        .word-content h2,
        .word-content h3 {
            color: var(--black);
            margin: 1.5rem 0 1rem;
        }

        .word-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .word-content th,
        .word-content td {
            border: 1px solid #ddd;
            padding: 0.5rem;
        }

        .word-content img {
            max-width: 100%;
            height: auto;
        }

        /* Excel Display */
        .excel-container {
            margin-top: 1rem;
        }

        .excel-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .excel-tab {
            padding: 0.5rem 1rem;
            background: #e8e8e8;
            border: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .excel-tab.active {
            background: #4CAF50;
            color: white;
        }

        .excel-content {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            overflow-x: auto;
            max-height: 70vh;
            overflow-y: auto;
        }

        .excel-content table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .excel-content th,
        .excel-content td {
            border: 1px solid #ddd;
            padding: 0.4rem 0.6rem;
            text-align: left;
            white-space: nowrap;
        }

        .excel-content th {
            background: #f5f5f5;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .excel-content tr:nth-child(even) {
            background: #fafafa;
        }

        /* PowerPoint Display */
        .ppt-container {
            margin-top: 1rem;
        }

        .ppt-viewer {
            width: 100%;
            height: 80vh;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #f5f5f5;
        }

        /* CSV Display (uses excel styles) */
        .csv-container {
            margin-top: 1rem;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar {
                position: relative;
                width: 100%;
                height: auto;
                padding: 2rem 1.5rem 1rem;
            }

            .social-links {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .social-links a,
            .social-links .orcid-link {
                width: auto;
                padding: 0.5rem;
                font-size: 0;
                gap: 0;
            }

            .social-links svg {
                width: 24px;
                height: 24px;
            }

            .social-links .hide-mobile {
                display: none;
            }

            .sidebar-footer {
                margin-top: 1rem;
            }

            .content {
                margin-left: 0;
                padding: 2rem 1rem;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                padding: 1.5rem 1rem 1rem;
            }

            .avatar {
                width: 80px;
                height: 80px;
            }

            h1 {
                font-size: 1.4rem;
            }

            article h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>

<body>

    <div class="layout">
        <aside class="sidebar" id="sidebar-content"></aside>
        <script src="/components/sidebar.js?v=20260128"></script>

        <main class="content">
            <a href="/blog/" class="back-link">‚Üê Back to Blog</a>

            <!-- Language Selector -->
            <div class="lang-selector" id="lang-selector" style="display: none;">
                <span class="lang-selector-label">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
                    </svg>
                    Language
                </span>
                <select class="lang-select" id="lang-select">
                    <option value="en">üá∫üá∏ English</option>
                    <option value="zh">üá®üá≥ ‰∏≠Êñá</option>
                    <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                    <option value="ko">üá∞üá∑ ÌïúÍµ≠Ïñ¥</option>
                    <option value="es">üá™üá∏ Espa√±ol</option>
                    <option value="fr">üá´üá∑ Fran√ßais</option>
                    <option value="de">üá©üá™ Deutsch</option>
                    <option value="pt">üáµüáπ Portugu√™s</option>
                    <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
                    <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                </select>
                <button class="lang-original-btn" id="lang-original-btn" style="display: none;">Show Original</button>
                <span class="lang-status" id="lang-status"></span>
            </div>

            <article id="article">
                <div class="loading">Loading...</div>
            </article>
        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mammoth@1/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script>
        // Get post name from URL: /blog/post.html?p=ddd-geocoding-client
        const params = new URLSearchParams(window.location.search);
        const postName = params.get('p');

        // Translation variables (declared early for use in content loading)
        let originalMarkdown = null;
        let savedArticleHtml = null;

        // Render notebook JSON to HTML
        function renderNotebook(notebook, notebookUrl) {
            const cells = notebook.cells || [];
            let html = '<div class="notebook-container">';

            // Download button
            html += `<a href="${notebookUrl}" download class="notebook-download">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
            Download Notebook (.ipynb)
        </a>`;

            let skipFirstMarkdown = true; // Skip frontmatter cell

            for (const cell of cells) {
                const source = Array.isArray(cell.source) ? cell.source.join('') : cell.source;

                if (cell.cell_type === 'markdown') {
                    // Skip frontmatter cell
                    if (skipFirstMarkdown && source.startsWith('---\n')) {
                        const afterFm = source.replace(/^---\n[\s\S]*?\n---\n?/, '');
                        if (afterFm.trim()) {
                            html += `<div class="nb-cell nb-cell-markdown">${marked.parse(afterFm)}</div>`;
                        }
                        skipFirstMarkdown = false;
                        continue;
                    }
                    skipFirstMarkdown = false;
                    html += `<div class="nb-cell nb-cell-markdown">${marked.parse(source)}</div>`;
                } else if (cell.cell_type === 'code') {
                    skipFirstMarkdown = false;
                    html += '<div class="nb-cell nb-cell-code">';
                    html += `<div class="nb-source"><pre><code class="language-python">${escapeHtml(source)}</code></pre></div>`;

                    // Render outputs
                    const outputs = cell.outputs || [];
                    for (const output of outputs) {
                        if (output.output_type === 'stream') {
                            const text = Array.isArray(output.text) ? output.text.join('') : output.text;
                            html += `<div class="nb-output"><pre>${escapeHtml(text)}</pre></div>`;
                        } else if (output.output_type === 'execute_result' || output.output_type === 'display_data') {
                            const data = output.data || {};
                            if (data['text/html']) {
                                const htmlContent = Array.isArray(data['text/html']) ? data['text/html'].join('') : data['text/html'];
                                html += `<div class="nb-output">${htmlContent}</div>`;
                            } else if (data['image/png']) {
                                html += `<div class="nb-output"><img src="data:image/png;base64,${data['image/png']}" /></div>`;
                            } else if (data['image/jpeg']) {
                                html += `<div class="nb-output"><img src="data:image/jpeg;base64,${data['image/jpeg']}" /></div>`;
                            } else if (data['text/plain']) {
                                const text = Array.isArray(data['text/plain']) ? data['text/plain'].join('') : data['text/plain'];
                                html += `<div class="nb-output"><pre>${escapeHtml(text)}</pre></div>`;
                            }
                        } else if (output.output_type === 'error') {
                            const traceback = (output.traceback || []).join('\n');
                            html += `<div class="nb-output" style="color: #c00;"><pre>${escapeHtml(traceback)}</pre></div>`;
                        }
                    }
                    html += '</div>';
                }
            }

            html += '</div>';
            return html;
        }

        function escapeHtml(text) {
            return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function postProcessArticle() {
            Prism.highlightAll();
            // Add line numbers and copy button to code blocks
            document.querySelectorAll('article pre').forEach(pre => {
                const code = pre.querySelector('code');
                if (code && !code.querySelector('.line')) {
                    const lines = code.innerHTML.split('\n');
                    if (lines[lines.length - 1] === '') lines.pop();
                    code.innerHTML = lines.map(line => `<span class="line">${line}</span>`).join('\n');
                    // Add copy button in toolbar
                    if (!pre.previousElementSibling?.classList?.contains('code-toolbar')) {
                        const toolbar = document.createElement('div');
                        toolbar.className = 'code-toolbar';
                        const btn = document.createElement('button');
                        btn.className = 'copy-btn';
                        btn.textContent = 'Copy';
                        btn.onclick = () => {
                            navigator.clipboard.writeText(code.textContent).then(() => {
                                btn.textContent = 'Copied!';
                                btn.classList.add('copied');
                                setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000);
                            });
                        };
                        toolbar.appendChild(btn);
                        pre.parentNode.insertBefore(toolbar, pre);
                    }
                }
            });
            // Render LaTeX math with KaTeX
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.getElementById('article'), {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\[', right: '\\]', display: true },
                        { left: '\\(', right: '\\)', display: false }
                    ],
                    throwOnError: false
                });
            }
        }

        // Render PDF with embedded viewer
        function renderPdf(pdfUrl, title) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;
            return `<div class="pdf-container">
            <h1>${escapeHtml(title)}</h1>
            <a href="${pdfUrl}" download class="doc-download">${downloadSvg} Download PDF</a>
            <iframe class="pdf-viewer" src="${pdfUrl}" type="application/pdf"></iframe>
        </div>`;
        }

        // Render TXT file
        function renderText(content, textUrl, title) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;
            return `<div class="text-container">
            <h1>${escapeHtml(title)}</h1>
            <a href="${textUrl}" download class="doc-download">${downloadSvg} Download Text File</a>
            <div class="text-content">${escapeHtml(content)}</div>
        </div>`;
        }

        // Render Word file using mammoth.js
        async function renderWord(docxUrl, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            try {
                const response = await fetch(docxUrl);
                const arrayBuffer = await response.arrayBuffer();
                const result = await mammoth.convertToHtml({ arrayBuffer });

                article.innerHTML = `<div class="word-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${docxUrl}" download class="doc-download">${downloadSvg} Download Word Document (.docx)</a>
                <div class="word-content">${result.value}</div>
            </div>`;
            } catch (err) {
                article.innerHTML = `<div class="text-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${docxUrl}" download class="doc-download">${downloadSvg} Download Word Document (.docx)</a>
                <p style="color: #666; margin-top: 1rem;">Unable to preview this document. Please download to view.</p>
            </div>`;
            }
        }

        // Render Excel file using SheetJS
        async function renderExcel(xlsxUrl, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            try {
                const response = await fetch(xlsxUrl);
                const arrayBuffer = await response.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });

                // Generate tabs for each sheet
                const sheetNames = workbook.SheetNames;
                const tabsHtml = sheetNames.map((name, i) =>
                    `<button class="excel-tab${i === 0 ? ' active' : ''}" data-sheet="${i}">${escapeHtml(name)}</button>`
                ).join('');

                // Generate table for first sheet
                const firstSheet = workbook.Sheets[sheetNames[0]];
                const tableHtml = XLSX.utils.sheet_to_html(firstSheet);

                article.innerHTML = `<div class="excel-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${xlsxUrl}" download class="doc-download">${downloadSvg} Download Excel (.xlsx)</a>
                <div class="excel-tabs">${tabsHtml}</div>
                <div class="excel-content">${tableHtml}</div>
            </div>`;

                // Add tab click handlers
                article.querySelectorAll('.excel-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        article.querySelectorAll('.excel-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        const sheetIndex = parseInt(tab.dataset.sheet);
                        const sheet = workbook.Sheets[sheetNames[sheetIndex]];
                        article.querySelector('.excel-content').innerHTML = XLSX.utils.sheet_to_html(sheet);
                    });
                });
            } catch (err) {
                article.innerHTML = `<div class="text-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${xlsxUrl}" download class="doc-download">${downloadSvg} Download Excel (.xlsx)</a>
                <p style="color: #666; margin-top: 1rem;">Unable to preview this spreadsheet. Please download to view.</p>
            </div>`;
            }
        }

        // Render PowerPoint file - with PDF preview if available
        async function renderPowerPoint(postName, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            const pptxUrl = `${postName}.pptx`;
            const pdfUrl = `${postName}.pdf`;

            // Check if PDF preview exists
            try {
                const pdfResponse = await fetch(pdfUrl, { method: 'HEAD' });
                if (pdfResponse.ok) {
                    // PDF exists - show PDF preview with both download options
                    article.innerHTML = `<div class="ppt-container">
                    <h1>${escapeHtml(title)}</h1>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <a href="${pdfUrl}" download class="doc-download">${downloadSvg} Download PDF</a>
                        <a href="${pptxUrl}" download class="doc-download" style="background: #D24726;">${downloadSvg} Download PPTX</a>
                    </div>
                    <iframe class="pdf-viewer" src="${pdfUrl}" type="application/pdf"></iframe>
                </div>`;
                    return;
                }
            } catch (e) { }

            // No PDF - show download only
            const pptIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 96 96" style="width: 80px; height: 80px; margin-bottom: 1rem;">
            <rect x="16" y="8" width="64" height="80" rx="4" fill="#D24726"/>
            <rect x="24" y="20" width="48" height="56" rx="2" fill="white"/>
            <text x="48" y="56" text-anchor="middle" font-size="20" font-weight="bold" fill="#D24726">PPT</text>
        </svg>`;

            article.innerHTML = `<div class="ppt-container">
            <h1>${escapeHtml(title)}</h1>
            <a href="${pptxUrl}" download class="doc-download">${downloadSvg} Download PowerPoint (.pptx)</a>
            <div style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 6px; padding: 3rem; text-align: center; min-height: 300px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                ${pptIcon}
                <p style="color: #666; margin-bottom: 0.5rem;">PowerPoint presentations cannot be previewed in browser.</p>
                <p style="color: #888; font-size: 0.85rem;">Please download the file to view it.</p>
            </div>
        </div>`;
        }

        // Render CSV file using SheetJS
        async function renderCsv(csvUrl, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            try {
                const response = await fetch(csvUrl);
                const text = await response.text();
                const workbook = XLSX.read(text, { type: 'string' });

                // CSV has only one sheet
                const sheet = workbook.Sheets[workbook.SheetNames[0]];
                const tableHtml = XLSX.utils.sheet_to_html(sheet);

                article.innerHTML = `<div class="csv-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${csvUrl}" download class="doc-download">${downloadSvg} Download CSV</a>
                <div class="excel-content">${tableHtml}</div>
            </div>`;
            } catch (err) {
                article.innerHTML = `<div class="text-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${csvUrl}" download class="doc-download">${downloadSvg} Download CSV</a>
                <p style="color: #666; margin-top: 1rem;">Unable to preview this CSV. Please download to view.</p>
            </div>`;
            }
        }

        // Render Image
        function renderImage(imageUrl, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;
            article.innerHTML = `<div class="image-container">
            <h1>${escapeHtml(title)}</h1>
            <a href="${imageUrl}" download class="doc-download">${downloadSvg} Download Image</a>
            <img src="${imageUrl}" alt="${escapeHtml(title)}" style="max-width: 100%; height: auto; border-radius: 6px; margin-top: 1rem;">
        </div>`;
        }

        // Render Video
        function renderVideo(videoUrl, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;
            article.innerHTML = `<div class="video-container">
            <h1>${escapeHtml(title)}</h1>
            <a href="${videoUrl}" download class="doc-download">${downloadSvg} Download Video</a>
            <video controls style="max-width: 100%; border-radius: 6px; margin-top: 1rem;">
                <source src="${videoUrl}" type="video/${videoUrl.split('.').pop()}">
                Your browser does not support the video tag.
            </video>
        </div>`;
        }

        // Render Audio
        function renderAudio(audioUrl, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;
            const audioIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width: 80px; height: 80px; color: #9C27B0; margin-bottom: 1rem;">
            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
        </svg>`;
            article.innerHTML = `<div class="audio-container" style="text-align: center; padding: 2rem;">
            <h1>${escapeHtml(title)}</h1>
            <a href="${audioUrl}" download class="doc-download">${downloadSvg} Download Audio</a>
            <div style="margin: 2rem 0;">${audioIcon}</div>
            <audio controls style="width: 100%; max-width: 500px;">
                <source src="${audioUrl}" type="audio/${audioUrl.split('.').pop().replace('mp3', 'mpeg')}">
                Your browser does not support the audio tag.
            </audio>
        </div>`;
        }

        // Render JSON with syntax highlighting
        async function renderJson(jsonUrl, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;
            try {
                const response = await fetch(jsonUrl);
                const json = await response.json();
                const formatted = JSON.stringify(json, null, 2);
                article.innerHTML = `<div class="code-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${jsonUrl}" download class="doc-download">${downloadSvg} Download JSON</a>
                <pre><code class="language-json">${escapeHtml(formatted)}</code></pre>
            </div>`;
                Prism.highlightAll();
            } catch (err) {
                article.innerHTML = `<div class="text-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${jsonUrl}" download class="doc-download">${downloadSvg} Download JSON</a>
                <p style="color: #666; margin-top: 1rem;">Unable to preview this JSON. Please download to view.</p>
            </div>`;
            }
        }

        // Render HTML in iframe
        function renderHtml(htmlUrl, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;
            article.innerHTML = `<div class="html-container">
            <h1>${escapeHtml(title)}</h1>
            <a href="${htmlUrl}" download class="doc-download">${downloadSvg} Download HTML</a>
            <a href="${htmlUrl}" target="_blank" class="doc-download" style="background: #E91E63; margin-left: 0.5rem;">Open in New Tab</a>
            <iframe src="${htmlUrl}" style="width: 100%; height: 80vh; border: 1px solid #ddd; border-radius: 6px; margin-top: 1rem; background: white;"></iframe>
        </div>`;
        }

        // Render Code file with syntax highlighting
        async function renderCode(codeUrl, title, article, ext) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;
            // Map extensions to Prism language classes
            const langMap = {
                'py': 'python', 'js': 'javascript', 'ts': 'typescript', 'go': 'go', 'java': 'java',
                'rs': 'rust', 'cpp': 'cpp', 'c': 'c', 'h': 'c', 'hpp': 'cpp',
                'rb': 'ruby', 'php': 'php', 'sh': 'bash', 'bash': 'bash', 'zsh': 'bash',
                'xml': 'xml', 'yaml': 'yaml', 'yml': 'yaml'
            };
            const lang = langMap[ext] || ext;
            try {
                const response = await fetch(codeUrl);
                const code = await response.text();
                article.innerHTML = `<div class="code-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${codeUrl}" download class="doc-download">${downloadSvg} Download ${ext.toUpperCase()}</a>
                <pre><code class="language-${lang}">${escapeHtml(code)}</code></pre>
            </div>`;
                Prism.highlightAll();
            } catch (err) {
                article.innerHTML = `<div class="text-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${codeUrl}" download class="doc-download">${downloadSvg} Download ${ext.toUpperCase()}</a>
                <p style="color: #666; margin-top: 1rem;">Unable to preview this file. Please download to view.</p>
            </div>`;
            }
        }

        // Render LaTeX - with PDF preview if available
        async function renderLatex(postName, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            const texUrl = `${postName}.tex`;
            const pdfUrl = `${postName}.pdf`;

            // Check if PDF preview exists
            try {
                const pdfResponse = await fetch(pdfUrl, { method: 'HEAD' });
                if (pdfResponse.ok) {
                    // PDF exists - show PDF preview with both download options
                    article.innerHTML = `<div class="latex-container">
                    <h1>${escapeHtml(title)}</h1>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <a href="${pdfUrl}" download class="doc-download">${downloadSvg} Download PDF</a>
                        <a href="${texUrl}" download class="doc-download" style="background: #009688;">${downloadSvg} Download LaTeX (.tex)</a>
                    </div>
                    <iframe class="pdf-viewer" src="${pdfUrl}" type="application/pdf"></iframe>
                </div>`;
                    return;
                }
            } catch (e) { }

            // No PDF - show source code with syntax highlighting
            try {
                const response = await fetch(texUrl);
                const tex = await response.text();
                article.innerHTML = `<div class="latex-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${texUrl}" download class="doc-download">${downloadSvg} Download LaTeX (.tex)</a>
                <pre><code class="language-latex">${escapeHtml(tex)}</code></pre>
            </div>`;
                Prism.highlightAll();
            } catch (err) {
                article.innerHTML = `<div class="text-container">
                <h1>${escapeHtml(title)}</h1>
                <a href="${texUrl}" download class="doc-download">${downloadSvg} Download LaTeX (.tex)</a>
                <p style="color: #666; margin-top: 1rem;">Unable to preview this file. Please download to view.</p>
            </div>`;
            }
        }

        // Render RTF - with PDF preview if available
        async function renderRtf(postName, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            const rtfUrl = `${postName}.rtf`;
            const pdfUrl = `${postName}.pdf`;

            // Check if PDF preview exists
            try {
                const pdfResponse = await fetch(pdfUrl, { method: 'HEAD' });
                if (pdfResponse.ok) {
                    // PDF exists - show PDF preview with both download options
                    article.innerHTML = `<div class="rtf-container">
                    <h1>${escapeHtml(title)}</h1>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <a href="${pdfUrl}" download class="doc-download">${downloadSvg} Download PDF</a>
                        <a href="${rtfUrl}" download class="doc-download" style="background: #5C6BC0;">${downloadSvg} Download RTF</a>
                    </div>
                    <iframe class="pdf-viewer" src="${pdfUrl}" type="application/pdf"></iframe>
                </div>`;
                    return;
                }
            } catch (e) { }

            // No PDF - show download only
            const rtfIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 96 96" style="width: 80px; height: 80px; margin-bottom: 1rem;">
            <rect x="16" y="8" width="64" height="80" rx="4" fill="#5C6BC0"/>
            <rect x="24" y="20" width="48" height="56" rx="2" fill="white"/>
            <text x="48" y="56" text-anchor="middle" font-size="16" font-weight="bold" fill="#5C6BC0">RTF</text>
        </svg>`;
            article.innerHTML = `<div class="rtf-container" style="text-align: center; padding: 2rem;">
            <h1>${escapeHtml(title)}</h1>
            <a href="${rtfUrl}" download class="doc-download">${downloadSvg} Download RTF</a>
            <div style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 6px; padding: 3rem; margin-top: 1rem; display: flex; flex-direction: column; align-items: center;">
                ${rtfIcon}
                <p style="color: #666; margin-bottom: 0.5rem;">RTF files cannot be previewed in browser.</p>
                <p style="color: #888; font-size: 0.85rem;">Please download to view in a word processor.</p>
            </div>
        </div>`;
        }

        // Render OpenDocument Text (ODT) - with PDF preview if available
        async function renderOdt(postName, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            const odtUrl = `${postName}.odt`;
            const pdfUrl = `${postName}.pdf`;

            // Check if PDF preview exists
            try {
                const pdfResponse = await fetch(pdfUrl, { method: 'HEAD' });
                if (pdfResponse.ok) {
                    article.innerHTML = `<div class="odt-container">
                    <h1>${escapeHtml(title)}</h1>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <a href="${pdfUrl}" download class="doc-download">${downloadSvg} Download PDF</a>
                        <a href="${odtUrl}" download class="doc-download" style="background: #2196F3;">${downloadSvg} Download ODT</a>
                    </div>
                    <iframe class="pdf-viewer" src="${pdfUrl}" type="application/pdf"></iframe>
                </div>`;
                    return;
                }
            } catch (e) { }

            // No PDF - show download only
            const odtIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 96 96" style="width: 80px; height: 80px; margin-bottom: 1rem;">
            <rect x="16" y="8" width="64" height="80" rx="4" fill="#2196F3"/>
            <rect x="24" y="20" width="48" height="56" rx="2" fill="white"/>
            <text x="48" y="56" text-anchor="middle" font-size="14" font-weight="bold" fill="#2196F3">ODT</text>
        </svg>`;
            article.innerHTML = `<div class="odt-container" style="text-align: center; padding: 2rem;">
            <h1>${escapeHtml(title)}</h1>
            <a href="${odtUrl}" download class="doc-download">${downloadSvg} Download ODT</a>
            <div style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 6px; padding: 3rem; margin-top: 1rem; display: flex; flex-direction: column; align-items: center;">
                ${odtIcon}
                <p style="color: #666; margin-bottom: 0.5rem;">OpenDocument Text files cannot be previewed in browser.</p>
                <p style="color: #888; font-size: 0.85rem;">Please download to view in LibreOffice or compatible software.</p>
            </div>
        </div>`;
        }

        // Render OpenDocument Spreadsheet (ODS) - with PDF preview if available
        async function renderOds(postName, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            const odsUrl = `${postName}.ods`;
            const pdfUrl = `${postName}.pdf`;

            // Check if PDF preview exists
            try {
                const pdfResponse = await fetch(pdfUrl, { method: 'HEAD' });
                if (pdfResponse.ok) {
                    article.innerHTML = `<div class="ods-container">
                    <h1>${escapeHtml(title)}</h1>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <a href="${pdfUrl}" download class="doc-download">${downloadSvg} Download PDF</a>
                        <a href="${odsUrl}" download class="doc-download" style="background: #4CAF50;">${downloadSvg} Download ODS</a>
                    </div>
                    <iframe class="pdf-viewer" src="${pdfUrl}" type="application/pdf"></iframe>
                </div>`;
                    return;
                }
            } catch (e) { }

            // No PDF - show download only
            const odsIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 96 96" style="width: 80px; height: 80px; margin-bottom: 1rem;">
            <rect x="16" y="8" width="64" height="80" rx="4" fill="#4CAF50"/>
            <rect x="24" y="20" width="48" height="56" rx="2" fill="white"/>
            <text x="48" y="56" text-anchor="middle" font-size="14" font-weight="bold" fill="#4CAF50">ODS</text>
        </svg>`;
            article.innerHTML = `<div class="ods-container" style="text-align: center; padding: 2rem;">
            <h1>${escapeHtml(title)}</h1>
            <a href="${odsUrl}" download class="doc-download">${downloadSvg} Download ODS</a>
            <div style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 6px; padding: 3rem; margin-top: 1rem; display: flex; flex-direction: column; align-items: center;">
                ${odsIcon}
                <p style="color: #666; margin-bottom: 0.5rem;">OpenDocument Spreadsheet files cannot be previewed in browser.</p>
                <p style="color: #888; font-size: 0.85rem;">Please download to view in LibreOffice or compatible software.</p>
            </div>
        </div>`;
        }

        // Render OpenDocument Presentation (ODP) - with PDF preview if available
        async function renderOdp(postName, title, article) {
            const downloadSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>`;

            const odpUrl = `${postName}.odp`;
            const pdfUrl = `${postName}.pdf`;

            // Check if PDF preview exists
            try {
                const pdfResponse = await fetch(pdfUrl, { method: 'HEAD' });
                if (pdfResponse.ok) {
                    article.innerHTML = `<div class="odp-container">
                    <h1>${escapeHtml(title)}</h1>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <a href="${pdfUrl}" download class="doc-download">${downloadSvg} Download PDF</a>
                        <a href="${odpUrl}" download class="doc-download" style="background: #FF9800;">${downloadSvg} Download ODP</a>
                    </div>
                    <iframe class="pdf-viewer" src="${pdfUrl}" type="application/pdf"></iframe>
                </div>`;
                    return;
                }
            } catch (e) { }

            // No PDF - show download only
            const odpIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 96 96" style="width: 80px; height: 80px; margin-bottom: 1rem;">
            <rect x="16" y="8" width="64" height="80" rx="4" fill="#FF9800"/>
            <rect x="24" y="20" width="48" height="56" rx="2" fill="white"/>
            <text x="48" y="56" text-anchor="middle" font-size="14" font-weight="bold" fill="#FF9800">ODP</text>
        </svg>`;
            article.innerHTML = `<div class="odp-container" style="text-align: center; padding: 2rem;">
            <h1>${escapeHtml(title)}</h1>
            <a href="${odpUrl}" download class="doc-download">${downloadSvg} Download ODP</a>
            <div style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 6px; padding: 3rem; margin-top: 1rem; display: flex; flex-direction: column; align-items: center;">
                ${odpIcon}
                <p style="color: #666; margin-bottom: 0.5rem;">OpenDocument Presentation files cannot be previewed in browser.</p>
                <p style="color: #888; font-size: 0.85rem;">Please download to view in LibreOffice or compatible software.</p>
            </div>
        </div>`;
        }
        function titleFromFilename(filename) {
            // Remove date prefix if present (yyyyMMdd-)
            let name = filename.replace(/^\d{8}-/, '');
            // Replace dashes/underscores with spaces and capitalize
            return name.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        }

        if (postName) {
            // Try different file types in order: md -> ipynb -> pptx -> rtf -> odt -> ods -> odp -> tex -> pdf -> txt -> docx -> xlsx -> csv -> images -> video -> audio -> json -> html -> code -> xml/yaml
            const article = document.getElementById('article');
            const filename = postName.split('/').pop();
            const title = titleFromFilename(filename);

            // Global variable to store post metadata (description, etc.)
            let postMeta = null;

            // Helper to inject description above content (for non-md posts)
            function injectDescription() {
                if (postMeta && postMeta.description) {
                    const descDiv = document.createElement('p');
                    descDiv.className = 'post-description';
                    descDiv.textContent = postMeta.description;
                    descDiv.style.cssText = 'color: #666; font-size: 1.1rem; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #ddd;';
                    // Insert after h1 or at the beginning
                    const h1 = article.querySelector('h1');
                    if (h1 && h1.nextSibling) {
                        h1.parentNode.insertBefore(descDiv, h1.nextSibling);
                    } else if (h1) {
                        h1.parentNode.appendChild(descDiv);
                    } else {
                        article.insertBefore(descDiv, article.firstChild);
                    }
                }
            }

            // First fetch posts.json to get metadata
            console.log('Fetching post:', postName);
            fetch('/blog/posts.json')
                .then(r => r.json())
                .then(posts => {
                    // Find current post by slug
                    postMeta = posts.find(p => p.slug === postName);
                    console.log('Post metadata:', postMeta);
                })
                .catch(err => console.log('Could not load posts.json:', err))
                .finally(() => {
                    // Now try to load the actual post content
                    const mdUrl = `${postName}.md`;
                    console.log('Fetching MD from:', new URL(mdUrl, window.location.href).href);

                    fetch(mdUrl)
                .then(r => {
                    console.log('MD Fetch response:', r.status, r.statusText);
                    if (!r.ok) throw new Error('not found');
                    return r.text();
                })
                .then(md => {
                    const frontmatterMatch = md.match(/^---\n[\s\S]*?\n---\n/);
                    const content = frontmatterMatch ? md.slice(frontmatterMatch[0].length) : md;
                    if (typeof marked === 'undefined') {
                        console.error('marked library not loaded');
                        article.innerHTML = '<p class="error">Error: Markdown library not loaded. Please check your internet connection.</p>';
                        throw new Error('done');
                    }
                    // Store original markdown for translation
                    originalMarkdown = content;
                    article.innerHTML = marked.parse(content);
                    const h1 = document.querySelector('article h1');
                    if (h1) document.title = h1.textContent + ' | Yuxu Ge';
                    postProcessArticle();
                    throw new Error('done'); // Stop chain
                })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.ipynb`); })
                .then(r => { if (r && !r.ok) throw new Error('not found'); return r?.json(); })
                .then(notebook => {
                    if (!notebook) return;
                    article.innerHTML = renderNotebook(notebook, `${postName}.ipynb`);
                    const h1 = document.querySelector('article h1');
                    if (h1) document.title = h1.textContent + ' | Yuxu Ge';
                    postProcessArticle();
                })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.pptx`, { method: 'HEAD' }); })
                .then(async r => {
                    if (r && r.ok) {
                        await renderPowerPoint(postName, title, article);
                        document.title = title + ' | Yuxu Ge';
                        throw new Error('done');
                    }
                    throw new Error('not found');
                })
                // RTF (before PDF to enable dual download)
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.rtf`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderRtf(postName, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // OpenDocument formats (before PDF to enable dual download)
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.odt`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderOdt(postName, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.ods`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderOds(postName, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.odp`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderOdp(postName, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // LaTeX (before PDF to enable dual download)
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.tex`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderLatex(postName, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // PDF (standalone, without source file)
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.pdf`, { method: 'HEAD' }); })
                .then(r => {
                    if (r && r.ok) {
                        article.innerHTML = renderPdf(`${postName}.pdf`, title);
                        document.title = title + ' | Yuxu Ge';
                        throw new Error('done'); // Stop chain
                    }
                    throw new Error('not found');
                })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.txt`); })
                .then(r => { if (r && !r.ok) throw new Error('not found'); return r?.text(); })
                .then(text => {
                    if (!text) return;
                    article.innerHTML = renderText(text, `${postName}.txt`, title);
                    document.title = title + ' | Yuxu Ge';
                })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.docx`, { method: 'HEAD' }); })
                .then(async r => {
                    if (r && r.ok) {
                        await renderWord(`${postName}.docx`, title, article);
                        document.title = title + ' | Yuxu Ge';
                        throw new Error('done');
                    }
                    throw new Error('not found');
                })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.xlsx`, { method: 'HEAD' }); })
                .then(async r => {
                    if (r && r.ok) {
                        await renderExcel(`${postName}.xlsx`, title, article);
                        document.title = title + ' | Yuxu Ge';
                        throw new Error('done');
                    }
                    throw new Error('not found');
                })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.csv`, { method: 'HEAD' }); })
                .then(async r => {
                    if (r && r.ok) {
                        await renderCsv(`${postName}.csv`, title, article);
                        document.title = title + ' | Yuxu Ge';
                        throw new Error('done');
                    }
                    throw new Error('not found');
                })
                // Images
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.jpg`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderImage(`${postName}.jpg`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.jpeg`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderImage(`${postName}.jpeg`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.png`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderImage(`${postName}.png`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.gif`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderImage(`${postName}.gif`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.webp`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderImage(`${postName}.webp`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.svg`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderImage(`${postName}.svg`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // Video
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.mp4`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderVideo(`${postName}.mp4`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.webm`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderVideo(`${postName}.webm`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // Audio
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.mp3`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderAudio(`${postName}.mp3`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.wav`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderAudio(`${postName}.wav`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.ogg`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderAudio(`${postName}.ogg`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // JSON
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.json`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderJson(`${postName}.json`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // HTML
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.html`, { method: 'HEAD' }); })
                .then(r => { if (r && r.ok) { renderHtml(`${postName}.html`, title, article); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // Code files
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.py`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.py`, title, article, 'py'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.js`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.js`, title, article, 'js'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.ts`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.ts`, title, article, 'ts'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.go`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.go`, title, article, 'go'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.java`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.java`, title, article, 'java'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.rs`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.rs`, title, article, 'rs'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.cpp`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.cpp`, title, article, 'cpp'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.c`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.c`, title, article, 'c'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.rb`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.rb`, title, article, 'rb'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.php`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.php`, title, article, 'php'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.sh`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.sh`, title, article, 'sh'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // XML/YAML
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.xml`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.xml`, title, article, 'xml'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.yaml`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.yaml`, title, article, 'yaml'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                .catch(e => { if (e.message === 'done') throw e; return fetch(`${postName}.yml`, { method: 'HEAD' }); })
                .then(async r => { if (r && r.ok) { await renderCode(`${postName}.yml`, title, article, 'yml'); document.title = title + ' | Yuxu Ge'; throw new Error('done'); } throw new Error('not found'); })
                // Final catch
                .catch(e => {
                    if (e.message !== 'done' && article.innerHTML.includes('Loading')) {
                        article.innerHTML = '<p class="error">Post not found.</p>';
                    }
                })
                .finally(() => {
                    // Inject description for non-markdown posts
                    injectDescription();
                });
                }); // End of finally from posts.json fetch
        } else {
            document.getElementById('article').innerHTML = '<p class="error">No post specified.</p>';
        }

        // ============================================================
        // TRANSLATION FEATURE
        // ============================================================
        const TRANSLATE_CONFIG = {
            apiUrl: 'https://yuxu.ge/api/translate',
            cacheKey: 'translation_cache',
            cacheTTL: 7 * 24 * 60 * 60 * 1000, // 7 days
        };

        // Translation state variables (originalMarkdown, savedArticleHtml declared at script start)
        let currentLang = 'en';
        let isTranslating = false;

        // Detect original language from content
        function detectLanguage(text) {
            // Simple heuristic: if > 30% Chinese characters, it's Chinese
            const chineseChars = (text.match(/[\u4e00-\u9fff]/g) || []).length;
            const totalChars = text.length;
            if (chineseChars / totalChars > 0.3) return 'zh';
            return 'en';
        }

        // Initialize language selector
        function initLanguageSelector() {
            const selector = document.getElementById('lang-selector');
            const select = document.getElementById('lang-select');
            const status = document.getElementById('lang-status');
            const originalBtn = document.getElementById('lang-original-btn');
            const article = document.getElementById('article');

            // Store original content
            savedArticleHtml = article.innerHTML;

            // Detect original language
            currentLang = detectLanguage(article.textContent);
            select.value = currentLang;

            // Show selector
            selector.style.display = 'flex';

            // Handle language change
            select.addEventListener('change', async (e) => {
                const targetLang = e.target.value;

                if (targetLang === currentLang && !isTranslating) {
                    // Show original
                    article.innerHTML = savedArticleHtml;
                    originalBtn.style.display = 'none';
                    status.textContent = '';
                    postProcessArticle();
                    return;
                }

                await translateArticle(targetLang);
            });

            // Show original button
            originalBtn.addEventListener('click', () => {
                article.innerHTML = savedArticleHtml;
                select.value = detectLanguage(article.textContent);
                originalBtn.style.display = 'none';
                status.textContent = '';
                postProcessArticle();
            });
        }

        // Translate article
        async function translateArticle(targetLang) {
            if (isTranslating) return;

            const article = document.getElementById('article');
            const status = document.getElementById('lang-status');
            const originalBtn = document.getElementById('lang-original-btn');

            // Check localStorage cache first
            const cacheKey = `${TRANSLATE_CONFIG.cacheKey}_${postName}_${targetLang}`;
            const cached = getTranslationCache(cacheKey);
            if (cached) {
                article.innerHTML = cached;
                status.textContent = '(cached)';
                status.className = 'lang-status cached';
                originalBtn.style.display = 'inline-block';
                postProcessArticle();
                return;
            }

            // Get content to translate (prefer markdown if available)
            let contentToTranslate = article.textContent;
            if (originalMarkdown) {
                contentToTranslate = originalMarkdown;
            }

            isTranslating = true;
            status.textContent = 'Translating...';
            status.className = 'lang-status translating';

            try {
                const response = await fetch(TRANSLATE_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content: contentToTranslate,
                        targetLang,
                        slug: postName,
                    }),
                });

                if (!response.ok) {
                    throw new Error(`Translation failed: ${response.status}`);
                }

                const data = await response.json();
                const translated = data.translated;

                // Render translated content
                if (originalMarkdown) {
                    // If we translated markdown, render it
                    article.innerHTML = marked.parse(translated);
                } else {
                    // Otherwise treat as HTML
                    article.innerHTML = marked.parse(translated);
                }

                // Cache in localStorage
                setTranslationCache(cacheKey, article.innerHTML);

                status.textContent = data.cached ? '(server cached)' : '(translated)';
                status.className = 'lang-status cached';
                originalBtn.style.display = 'inline-block';

                postProcessArticle();

            } catch (err) {
                console.error('Translation error:', err);
                status.textContent = 'Translation failed';
                status.className = 'lang-status';
                // Revert to original
                setTimeout(() => {
                    status.textContent = '';
                }, 3000);
            } finally {
                isTranslating = false;
            }
        }

        // LocalStorage cache helpers
        function getTranslationCache(key) {
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return null;
                const data = JSON.parse(raw);
                if (Date.now() - data.timestamp > TRANSLATE_CONFIG.cacheTTL) {
                    localStorage.removeItem(key);
                    return null;
                }
                return data.content;
            } catch (e) {
                return null;
            }
        }

        function setTranslationCache(key, content) {
            try {
                localStorage.setItem(key, JSON.stringify({
                    content,
                    timestamp: Date.now(),
                }));
            } catch (e) {
                console.warn('Cache write failed:', e);
            }
        }

        // Initialize after content loads
        const checkContentLoaded = setInterval(() => {
            const article = document.getElementById('article');
            if (article && !article.innerHTML.includes('Loading')) {
                clearInterval(checkContentLoaded);
                // Wait a bit for post-processing
                setTimeout(initLanguageSelector, 100);
            }
        }, 100);

        // Clear check after 10 seconds
        setTimeout(() => clearInterval(checkContentLoaded), 10000);
    </script>

</body>

</html>