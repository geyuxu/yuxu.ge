<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My AI Coding Partner Almost Drove My Project Off a Cliff: A Cautionary Tale | Yuxu Ge</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --black: #111;
            --dark-grey: #444;
            --off-white: #f4f4f4;
            --vermilion: #C41E3A;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--black);
            background-color: var(--off-white);
        }

        a { color: var(--vermilion); text-decoration: none; }
        a:hover { opacity: 0.75; }

        .layout { min-height: 100vh; }

        /* Sidebar */
        .sidebar {
            position: fixed; top: 0; left: 0;
            width: 320px; height: 100vh;
            background: var(--black); color: var(--off-white);
            padding: 3rem 2rem;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .sidebar-top { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .avatar { display: block; width: 120px; height: 120px; border-radius: 50%; border: 3px solid var(--vermilion); margin-bottom: 1.5rem; overflow: hidden; transition: transform 0.2s ease; }
        .avatar:hover { opacity: 1; transform: scale(1.05); }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .name-block { margin-bottom: 0.5rem; }
        h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: 1px; color: var(--off-white); }
        .title-role { font-size: 0.9rem; color: #888; margin-top: 0.25rem; font-weight: 400; }
        .contact-block { margin-top: 2.5rem; width: 100%; }
        .social-links { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .social-links a { display: flex; align-items: center; gap: 0.75rem; width: 160px; color: var(--off-white); opacity: 0.7; padding: 0.5rem 0.75rem; border-radius: 4px; font-size: 0.9rem; transition: all 0.2s; }
        .social-links a:hover { color: var(--vermilion); opacity: 1; background: rgba(255,255,255,0.05); }
        .social-links svg { width: 20px; height: 20px; flex-shrink: 0; }
        .social-links .orcid-link { font-size: 0.68rem; gap: 0.5rem; white-space: nowrap; }
        .sidebar-footer { text-align: center; font-size: 0.75rem; color: #555; }

        /* Content */
        .content { margin-left: 320px; padding: 3rem 4rem; max-width: 900px; }
        .back-link { display: inline-block; font-size: 0.85rem; margin-bottom: 2rem; color: var(--dark-grey); }
        .back-link:hover { color: var(--vermilion); }

        /* Article */
        article h1 { font-size: 2rem; font-weight: 700; margin-bottom: 1.5rem; line-height: 1.3; color: var(--black); }
        article h2 { font-size: 1.4rem; font-weight: 600; margin: 2rem 0 1rem; color: var(--black); }
        article h3 { font-size: 1.1rem; font-weight: 600; margin: 1.5rem 0 0.75rem; color: var(--black); }
        article p { margin-bottom: 1rem; color: var(--dark-grey); }
        article ul, article ol { margin: 1rem 0 1rem 1.5rem; color: var(--dark-grey); }
        article li { margin-bottom: 0.5rem; }
        article strong { color: var(--black); }
        article code { font-family: "SF Mono", Monaco, monospace; font-size: 0.9em; background: #e8e8e8; padding: 0.15em 0.4em; border-radius: 3px; }
        article pre { margin: 1rem 0; border-radius: 6px; overflow-x: auto; background: #2d2d2d; padding: 1rem; }
        article pre code { background: none; padding: 0; font-size: 0.75em; white-space: pre !important; counter-reset: line; display: block; color: #ccc; }
        article pre code .line { counter-increment: line; }
        article pre code .line::before { content: counter(line); display: inline-block; width: 2.5em; margin-right: 1em; text-align: right; color: #666; user-select: none; }
        .code-toolbar { display: flex; justify-content: flex-start; padding: 0.35rem 0.5rem; background: #3a3a3a; border-radius: 6px 6px 0 0; }
        .code-toolbar + pre { margin-top: 0; border-radius: 0 0 6px 6px; }
        .copy-btn { padding: 0.2rem 0.5rem; font-size: 0.7rem; background: #555; color: #fff; border: none; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
        .copy-btn:hover, .copy-btn:active { background: #777; }
        .copy-btn.copied { background: #2a2; }
        article blockquote { border-left: 3px solid var(--vermilion); padding-left: 1rem; margin: 1rem 0; color: #666; font-style: italic; }
        article hr { border: none; border-top: 1px solid #ddd; margin: 2rem 0; }
        article table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        article th, article td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
        article th { background: #e8e8e8; font-weight: 600; }
        article img { max-width: 100%; height: auto; display: block; margin: 1.5rem 0; border-radius: 6px; }

        .loading { text-align: center; padding: 3rem; color: #888; }
        .error { color: var(--vermilion); }

        /* KaTeX math styles */
        .katex-display { overflow-x: auto; overflow-y: hidden; padding: 0.5rem 0; }
        .katex { font-size: 1.1em; }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { position: relative; width: 100%; height: auto; padding: 2rem 1.5rem 1rem; }
            .social-links { flex-direction: row; flex-wrap: wrap; justify-content: center; }
            .social-links a, .social-links .orcid-link { width: auto; padding: 0.5rem; font-size: 0; gap: 0; }
            .social-links svg { width: 24px; height: 24px; }
            .social-links .hide-mobile { display: none; }
            .sidebar-footer { margin-top: 1rem; }
            .content { margin-left: 0; padding: 2rem 1rem; }
        }
        @media (max-width: 480px) {
            .sidebar { padding: 1.5rem 1rem 1rem; }
            .avatar { width: 80px; height: 80px; }
            h1 { font-size: 1.4rem; }
            article h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="layout">
    <aside class="sidebar" id="sidebar-content"></aside>
    <script src="/components/sidebar.js"></script>

    <main class="content">
        <a href="/blog/" class="back-link">← Back to Blog</a>
        <article>
<hr>
<h2>date: 2025-07-27
tags: [ai, ai, software development, architecture, best practices, asyncio, python]
legacy: true</h2>
<h1>My AI Coding Partner Almost Drove My Project Off a Cliff: A Cautionary Tale</h1>
<ol>
<li><strong>Core Scheduling Engine:</strong> A robust, <code>asyncio</code>-based scheduler.</li>
<li><strong>Intelligent Task Execution:</strong> A system that could analyze task outcomes and dynamically adjust parameters for future runs.</li>
<li><strong>Auto-Improving Task Generation:</strong> A feature where the AI could rewrite a task&#39;s underlying script based on performance metrics or failures.</li>
<li><strong>Human Ticketing System:</strong> When a task failed irrecoverably, the system would generate a &quot;ticket,&quot; which a human could review, annotate with a solution, and feed back into the system&#39;s knowledge base.</li>
</ol>
<p>The AI dutifully churned out code. The ticketing system was built, the self-improvement hooks were added, and the scheduler was wired up. On the surface, it looked like a massive success. The problem was that I was acting as a project manager, not an architect. I was specifying <em>what</em> to build, but I wasn&#39;t rigorously guiding <em>how</em> it was built and integrated.</p>
<h2>The Collision with Reality: Four Horsemen of the AI-pocalypse</h2>
<p>The rapid, un-reviewed development cycle papered over deep-seated issues. When I finally tried to run the integrated system, it collapsed. The root causes were not novel or exotic; they were classic software engineering failures, amplified and accelerated by AI.</p>
<h3>1. The Siren&#39;s Call of Over-engineering</h3>
<p>The AI doesn&#39;t have the business context or architectural foresight to say, &quot;This is too much for one go.&quot; It is an incredibly powerful implementation engine. By asking for everything at once, I had inadvertently directed it to build a solution for a future that didn&#39;t exist yet, ignoring the immediate need for a stable foundation. The &quot;intelligent&quot; features were bolted onto a core that had never been pressure-tested, creating a solution in search of a problem.</p>
<h3>2. The Technical Debt Avalanche</h3>
<p>This is where the theoretical problems became painfully concrete. The AI, in its effort to satisfy all requests, made expedient choices that created fundamental conflicts.</p>
<p>The most glaring issue was the <code>asyncio</code> event loop conflict. Different modules, likely developed in separate AI prompts, were trying to manage the event loop independently. For example, the core scheduler might have been initialized with:</p>
<p><strong>Problematic Code Snippet 1: Conflicting Event Loops</strong></p>
<pre><code class="language-python"><span class="line"># In scheduler_core.py, generated by one prompt</span>
<span class="line">import asyncio</span>
<span class="line">from apscheduler.schedulers.asyncio import AsyncIOScheduler</span>
<span class="line"></span>
<span class="line">class MainScheduler:</span>
<span class="line">    def __init__(self):</span>
<span class="line">        self.scheduler = AsyncIOScheduler()</span>
<span class="line"></span>
<span class="line">    def run(self):</span>
<span class="line">        self.scheduler.start()</span>
<span class="line">        # This call blocks forever, running the loop.</span>
<span class="line">        asyncio.get_event_loop().run_forever() </span>
<span class="line"></span>
<span class="line"># In ticketing_system.py, generated by another prompt</span>
<span class="line">import asyncio</span>
<span class="line"></span>
<span class="line">class TicketingSystem:</span>
<span class="line">    async def process_ticket(self, ticket_data):</span>
<span class="line">        # ... logic ...</span>
<span class="line">        print(&quot;Processing ticket&quot;)</span>
<span class="line"></span>
<span class="line">    def handle_failed_task(self, task_info):</span>
<span class="line">        # This is the anti-pattern! It tries to run a new loop.</span>
<span class="line">        asyncio.run(self.process_ticket(task_info))</span></code></pre>
<p>When <code>handle_failed_task</code> was called by the running scheduler, it would crash with a <code>RuntimeError: This event loop is already running</code>. The AI, focusing on the local context of the ticketing system, used the convenient <code>asyncio.run()</code>, unaware that it was part of a larger, already-running event loop.</p>
<p>Furthermore, the choice of <code>apscheduler</code>&#39;s <code>CronTrigger</code> introduced another layer of complexity. Its blocking nature and separate threading model didn&#39;t mesh cleanly with the fully asynchronous design I envisioned, leading to timing bugs and difficult-to-debug race conditions.</p>
<h3>3. The Ghost in the Machine: The Peril of Unsupervised Development</h3>
<p>My development process was flawed. I was treating the AI as an autonomous developer, giving it a list of features and expecting a coherent result. I had abdicated my role as the architect and reviewer.</p>
<p>A human developer, if asked to build all this, would have pushed back. They would have asked for clarification, proposed a phased rollout, and raised concerns about complexity. The AI did not. It simply executed, weaving a tangled web without the holistic understanding that comes from experience. Without regular, manual code reviews and integration testing at each step, I was blind to the accumulating architectural rot.</p>
<h3>4. The Architectural Tangle</h3>
<p>The end result was a tightly coupled monolith. The &quot;Auto-Improving Task Generation&quot; module had direct dependencies on the <code>TicketingSystem</code>&#39;s internal data structures. The <code>MainScheduler</code> knew intimate details about how the &quot;Intelligent Task Execution&quot; module worked.</p>
<p><strong>Conceptual Problem: Tight Coupling</strong></p>
<pre><code class="language-python"><span class="line"># Before: A tangled mess of dependencies</span>
<span class="line">class MainScheduler:</span>
<span class="line">    def __init__(self):</span>
<span class="line">        # The scheduler directly instantiates its &quot;smart&quot; components</span>
<span class="line">        self.improver = AutoTaskImprover()</span>
<span class="line">        self.ticketer = TicketingSystem()</span>
<span class="line"></span>
<span class="line">    def _execute_task(self, task):</span>
<span class="line">        result = task.run()</span>
<span class="line">        if not result.success:</span>
<span class="line">            # Direct call into another module&#39;s implementation</span>
<span class="line">            new_script = self.improver.analyze_and_suggest_fix(task.script, result.error)</span>
<span class="line">            if new_script:</span>
<span class="line">                task.update_script(new_script)</span>
<span class="line">            else:</span>
<span class="line">                # Another direct, deep call</span>
<span class="line">                self.ticketer.handle_failed_task(task.info) </span></code></pre>
<p>Debugging was a nightmare. A failure in one component would cascade through the system, making it impossible to isolate the root cause. The system was not a collection of cooperating modules; it was a single, fragile machine.</p>
<h2>The Recovery: Lessons for a Human-AI Partnership</h2>
<p>Crawling back from this brink was an exercise in humility and a return to first principles. The recovery process gave me a clear framework for working with AI, one that leverages its power without succumbing to its pitfalls.</p>
<h3>Lesson 1: Embrace Incrementalism (The &quot;Crawl, Walk, Run&quot; Method)</h3>
<p>The first step was to tear it all down. I started again with a single, clear goal: build a rock-solid, simple, asynchronous task scheduler. No &quot;intelligence,&quot; no &quot;self-improvement.&quot; Just a stable core.</p>
<p>Only after this core was built, tested, and proven did I begin to add the AI features back, one by one. Each new feature was developed as a distinct, optional module, not a core component.</p>
<p><strong>The Fix: A Modular, Pluggable Architecture</strong></p>
<pre><code class="language-python"><span class="line"># After: A clean, decoupled design using dependency injection</span>
<span class="line"></span>
<span class="line"># --- Core Scheduler (knows nothing about &quot;smart&quot; features) ---</span>
<span class="line">class MainScheduler:</span>
<span class="line">    def __init__(self, plugins=None):</span>
<span class="line">        self.plugins = plugins or []</span>
<span class="line"></span>
<span class="line">    def _execute_task(self, task):</span>
<span class="line">        result = task.run()</span>
<span class="line">        if not result.success:</span>
<span class="line">            # The core only publishes an event, it doesn&#39;t know the consumers.</span>
<span class="line">            self.publish_event(&#39;task_failed&#39;, task=task, result=result)</span>
<span class="line"></span>
<span class="line">    def publish_event(self, event_type, **kwargs):</span>
<span class="line">        for plugin in self.plugins:</span>
<span class="line">            if hasattr(plugin, f&quot;on_{event_type}&quot;):</span>
<span class="line">                getattr(plugin, f&quot;on_{event_type}&quot;)(**kwargs)</span>
<span class="line"></span>
<span class="line"># --- Optional Plugin ---</span>
<span class="line">class AutoImprovementPlugin:</span>
<span class="line">    def on_task_failed(self, task, result):</span>
<span class="line">        # Logic to improve task is now isolated here</span>
<span class="line">        print(f&quot;Plugin: Analyzing failure for task {task.id}&quot;)</span>
<span class="line">        # ...</span>
<span class="line"></span>
<span class="line"># --- Main application wiring ---</span>
<span class="line">core_scheduler = MainScheduler(plugins=[AutoImprovementPlugin()])</span>
<span class="line"># Now the smart feature is an optional plugin, not a core dependency.</span></code></pre>
<p>This approach keeps the core clean and allows features to be enabled, disabled, or replaced without affecting the rest of the system.</p>
<h3>Lesson 2: The Human-in-the-Loop is Non-Negotiable</h3>
<p>I changed my role from &quot;project manager&quot; to &quot;lead architect and senior developer.&quot; The AI is my brilliant but inexperienced junior partner. My new workflow looks like this:</p>
<ol>
<li><strong>Define a small, isolated task.</strong> (e.g., &quot;Create a plugin class that logs task failures to a JSON file.&quot;)</li>
<li><strong>AI generates the code.</strong></li>
<li><strong>I critically review every line.</strong> I check for anti-patterns, architectural mismatches, and incorrect assumptions.</li>
<li><strong>I refactor and integrate the code myself.</strong> I am the one who connects it to the main application, ensuring it adheres to the established architecture.</li>
<li><strong>I write the integration tests and commit.</strong></li>
</ol>
<p>This human-centric loop is the single most important change I made. It keeps me in control of the architecture and quality.</p>
<h3>Lesson 3: Simple is (Still) Better Than Complex</h3>
<p>The <code>asyncio</code> problem was solved by enforcing a single, simple rule: there is only one event loop, and it is managed by the application&#39;s entry point. Modules and plugins must never call <code>asyncio.run()</code> or <code>loop.run_forever()</code>. Instead, they expose <code>async</code> functions that the main loop can <code>await</code>.</p>
<p><strong>The Fix: A Single, Unified Event Loop</strong></p>
<pre><code class="language-python"><span class="line"># In a plugin file (e.g., ticketing_plugin.py)</span>
<span class="line">class TicketingPlugin:</span>
<span class="line">    async def on_task_failed(self, task, result):</span>
<span class="line">        # This function is now async and expects to be awaited</span>
<span class="line">        await self.create_ticket(task.info)</span>
<span class="line"></span>
<span class="line">    async def create_ticket(self, info):</span>
<span class="line">        print(f&quot;Creating ticket for {info}&quot;)</span>
<span class="line">        # ... await async I/O operations ...</span>
<span class="line">        await asyncio.sleep(0.1) </span>
<span class="line"></span>
<span class="line"># In the main application entry point</span>
<span class="line">async def main():</span>
<span class="line">    # Plugins are now designed to be awaited</span>
<span class="line">    ticketing_plugin = TicketingPlugin()</span>
<span class="line">    scheduler = MainScheduler(plugins=[ticketing_plugin])</span>
<span class="line">    </span>
<span class="line">    # The scheduler&#39;s `publish_event` would need to be async</span>
<span class="line">    # and await the plugin calls.</span>
<span class="line">    </span>
<span class="line">    # ... startup logic ...</span>
<span class="line">    await scheduler.run() # The main run function is now awaitable</span>
<span class="line"></span>
<span class="line">if __name__ == &quot;__main__&quot;:</span>
<span class="line">    # The one and only place the event loop is run</span>
<span class="line">    asyncio.run(main())</span></code></pre>
<p>This architectural principle—simplicity—must be enforced by the human developer. An AI, optimizing for a local goal, may not choose the simplest global path.</p>
<h2>Final Thoughts: The Pilot, Not the Passenger</h2>
<p>AI development tools are not autonomous pilots for your projects; they are incredibly powerful copilots. They can handle complex maneuvers, process vast amounts of information, and execute instructions with superhuman speed. But the human developer must remain the pilot-in-command, responsible for the flight plan (architecture), the pre-flight checks (code reviews), and the ultimate direction of the journey.</p>
<p>My experience with Nighthawks taught me that the promise of AI is real, but it requires a new kind of discipline. We must resist the temptation to let it run unsupervised. Instead, we must guide it, question it, and integrate its output with the wisdom and foresight that only a human architect can provide.</p>
<p>By pairing our strategic oversight with the AI&#39;s tactical prowess, we can avoid flying into a storm of complexity and instead navigate toward building truly remarkable software.</p>
<h2>Key Takeaways</h2>
<ol>
<li><strong>Start Simple</strong>: Build a solid foundation before adding intelligent features</li>
<li><strong>Human Review is Critical</strong>: Every AI-generated code needs human architectural review</li>
<li><strong>Modular Design</strong>: Keep features optional and loosely coupled</li>
<li><strong>Incremental Development</strong>: Add one feature at a time and test thoroughly</li>
<li><strong>Architecture Matters</strong>: The human must remain the architect, not just the project manager</li>
</ol>
<p>The future of software development lies not in replacing human judgment with AI, but in creating a partnership where each contributes their unique strengths to build better software, faster and more reliably.</p>

    </article>
    </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
<script>
Prism.highlightAll();
document.querySelectorAll('article pre').forEach(pre => {
    const code = pre.querySelector('code');
    if (!code) return;
    const toolbar = document.createElement('div');
    toolbar.className = 'code-toolbar';
    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = () => {
        navigator.clipboard.writeText(code.textContent).then(() => {
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 2000);
        });
    };
    toolbar.appendChild(btn);
    pre.parentNode.insertBefore(toolbar, pre);
});
</script>
</body>
</html>