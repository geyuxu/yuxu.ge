---
date: 2021-10-12
tags: [general_notes]
legacy: true
---

# 批量行政区代码更新脚本实战笔记

## 脚本生成思路
* 源数据整理至 CSV：`STORE_CODE,STORE_TYPE,OLD_AREA,NEW_AREA`。
* 使用简单 Python 模版批量输出：
```python
import csv, datetime
tpl = "update site_store set area = {new} where store_code = '{code}' and store_type = '{typ}';"
with open('mapping.csv') as f, open('update.sql','w') as out:
    for row in csv.DictReader(f):
        out.write(tpl.format(**row)+'\n')
```
* 模板优势：
* 可读性强，后期维护仅需修改 CSV。
* 支持追加其他字段（如 city）而无需改脚本主体。

## 执行前校验
* 备份：
  * 利用 `CREATE TABLE site_store_bak AS SELECT * FROM site_store WHERE store_code IN (...)` 备份受影响行。

* 常量检查：
  * `SELECT COUNT(1) FROM site_store_bak` 与脚本行数一致。
  * 编码有效性：通过 `sys_area` 字典表校验 `new_area` 均存在。


## 最佳执行姿势
* 会话设置：
```sql
SET SERVEROUTPUT ON
WHENEVER SQLERROR EXIT SQL.SQLCODE
```
* 使用 `@update.sql` 执行，遇错即停。
* 分批提交：
  * 每 500 条 COMMIT 一次，减少回滚体积。


## 校验与回滚
* 快速校验：
  * `SELECT COUNT(*) WHERE area = new_area` 验证成功率。

* 聚合对比：`SUM(old_area)` vs `SUM(new_area)`。
* 回滚方案：若发现误更新，使用 `MERGE` 将备份表写回原表。

## 常见坑
* **行锁争抢**：门店表被其他业务写入，可在夜间窗口操作。
* **错误编码**：脚本中若写错 `WHERE` 条件，可能更新全国门店。务必在测试库实测并 `EXPLAIN PLAN` 确认命中行。
* **权限问题**：生产执行需 DBA 协助，提前走变更流程。

## 优化与扩展
* 改用 **MERGE INTO** 一次完成：
```sql
MERGE INTO site_store s USING tmp_area_map m
ON (s.store_code = m.store_code AND s.store_type = m.store_type)
WHEN MATCHED THEN UPDATE SET s.area = m.new_area;
```
* 加 `CHECK(area IN (SELECT id FROM sys_area))` 防止脏数据。
* 自动化校验：脚本执行完触发 Jenkins Job，对比异常差异并出报警。

## 总结
* 批量数据脚本需求看似简单，核心在于 **生成可靠脚本** + **完善备份校验**。
* 小型场景用单条 `UPDATE` 直观易读；大规模可考虑 `MERGE` 或 ETL 工具。
* 数据治理应在源头加约束，降低后期修补成本。